// Sample jQuery plugin pattern

// (function ($, window) {

// 	$.samplePlugin = function(elem) {
// 		var base 	= this;
// 		base.$elem 	= $(elem);

// 	$.fn.samplePlugin = function() {
// 		return this.each( function() {
// 			var samplePlugin = new $.samplePlugin(this);
// 		});
// 	};

// } (jQuery, window));
var PathOS = PathOS || {};

PathOS.version = "PathOS.js build: 26th of May 2016";


// Simple way for PathOS to store data
// Currently uses localStorage but could be upgraded in future.
// DKGM 28-06-2016
PathOS.data = {
	// Provide a key and a default object
	load: function(key, obj) {
		var result = obj || {};
		if (localStorage["PathOS-"+key]) {
			result = JSON.parse(localStorage["PathOS-"+key]);
		}
		return result;
	},
	// Save the object with the key
	save: function(key, obj) {
		localStorage["PathOS-"+key] = JSON.stringify(obj);
	},
	// Clear the key's data
	clear: function(key) {
		delete localStorage["PathOS-"+key];
	},
	clean: function() {
		delete localStorage['PathOS-history'];
		delete localStorage['PathOS-modules'];
	}
};


/**
 * This function adds a module to the sidebar.
 *
 *
 *
 * @param config
 *
 */

PathOS.module = function(config) {

	//console.log("Adding PathOS module... "+config.name);
	var that = this;
	PathOS.modules.map[config.name] = {
		data: config,
		object: that
	};

	// Get the div or create one.
	var div = d3.select('#'+config.name);
	if(div.empty()) {
		div = this.div = d3.select("#sidebar")
			.append("div")
			.classed("module", true)
			.attr("id", config.name);
	}

	// Get the title or create one.
	var title = div.select(".moduletitle");
	if(title.empty()) {
		title = div.append('table').classed("moduletitle", true).append('tr');

		title.append('td')
			.classed("modulelabel", true)
			.datum(config)
			.on("click", that.toggle)
		.append("a")
			.attr('href', "#" + config.name)
		.append("h1")
			.text(config.title);
	} else {
		title.select('td').classed("modulelabel", true).datum(config).on("click", that.toggle);
	}

	title.insert('td','td')
		.datum(config)
		.on("click", that.toggle)
	.append("a")
		.attr('href', "#"+config.name)
	.append("i")
		.classed("fa fa-minus-square minimise", true);

	//buttons = title.append('td').classed('buttons', true);


	// Get the content or create one.


	function buildHistoryRow(d){

		var type = '';
		if(d.title.toLowerCase().indexOf('seqrun') >= 0) {
			type = 'Seqrun';
		} else if(d.title.toLowerCase().indexOf('pubmed') >= 0) {
			type = 'Pubmed';
		} else if(d.title.toLowerCase().indexOf('sequenced variants list') >= 0) {
			type = 'SeqSample';
		} else if(d.title.toLowerCase().indexOf('curvar') >= 0) {
			type = 'CurVariant';
		} else if(d.title.toLowerCase().indexOf('patient') >= 0) {
			type = 'PatSample';
		}

        //
		//row.append('td').append('i').classed('document-icon fa fa-wpforms', true)
		//	.classed(type, true);


		var row = body.append('tr');
		row.append('td')
			.append('a')
			.attr('href', d.url).text(d.title).classed(type, true);

		row.append('td').text(PathOS.timeSince(d.time));
	}

	if(config.type) {
		var content = div.append('div').classed('content', true);
		switch (config.type) {
			case 'tags':

				var edit = title.append('td').attr('id', 'tags_edit_button')
					.on('click',function(){
						$("#tags").toggleClass("editing");

						$('#tags_edit_button i').toggleClass('fa-pencil-square-o');
						$('#tags_edit_button i').toggleClass('fa-pencil-square');


					})
					.append("a").attr('href', "#"+config.name);

				//edit.append('p').text("(Editing)");
				edit.append('span').html("(Editing)&nbsp;");
				edit.append("i").classed("button fa fa-pencil-square-o", true);

				title.append('td').append("a").attr('href', "#"+config.name)
					.append("i")
					.classed("fa fa-times", true)
					.style("padding-bottom", '1px')
					.on('click', function(d){
						d3.select("#"+config.name).style('display','none');
						config.closeModule();
					});

				d3.select("#tags").style('display','none');
				var row = content.append('table')
					.append('thead')
					.append("tr").classed('row',true);
				row.append('th').text(config.data.object);
				row.append('th').text("").attr("id","object_id").style('text-align','right');

				var box = content.append('div').classed('fb-box tags_field', true)
					.attr("id", 'moduleTagBox')
					.on('click', function(){
						$('#tag_text_area').focus();
					});

				config.data.tags.forEach(function(tag){
					PathOS.tags.drawTag(box, tag, true);
				});

				box.append('textarea')
					.attr('id', 'tag_text_area')
					.attr('placeholder', 'Enter Tags Here');

				$("#tag_text_area").autocomplete({
				    source: config.data.availableTags
				});


				$('body').on("keydown", function(e){
					if (e && e.keyCode && e.keyCode == 13 && $(document.activeElement).is("#tag_text_area")){

						var tag = $('#tag_text_area').val().trim();
						$('#tag_text_area').val('');

						//console.log("submitting tag! "+tag);
						if (tag && tag !== '' && PathOS.tags.current_object) {
							PathOS.tags.addTag(box, tag);
						}

					} else if (e && e.keyCode && e.keyCode == 8 && $(document.activeElement).is("#tag_text_area") && $("#tag_text_area").val() === ""){
						if($("#moduleTagBox.tags_field .tagdiv:last").length !== 0){
							if ($("#moduleTagBox.tags_field .tagdiv:last").hasClass('deleteFlag')) {
								var data = d3.select($("#moduleTagBox.tags_field .tagdiv:last")[0]).datum();

								if(confirm('Remove tag "'+data.label+'" from this object?')) {
									var params = {
										type: PathOS.controller,
										objid: PathOS.tags.current_object,
										tagid: data.id
									};
									$.ajax({
										type: "DELETE",
										url: "/PathOS/tag/removeLink?" + $.param(params),
										success: function (result) {
											if(result != 'fail') {
												$('.tag-'+data.id).remove();
												if(reloadGrid) {
													reloadGrid();
												}
											}
										},
										cache: false,
										contentType: false,
										processData: false
									});
								}
							} else {
								$("#moduleTagBox.tags_field .tagdiv:last").toggleClass("deleteFlag").on('click', function(){
									var data = d3.select($("#moduleTagBox.tags_field .tagdiv:last")[0]).datum();
									var params = {
										type: PathOS.controller,
										objid: PathOS.tags.current_object,
										tagid: data.id
									};
									$.ajax({
										type: "DELETE",
										url: "/PathOS/tag/removeLink?" + $.param(params),
										success: function (result) {
											if(result != 'fail') {
												$('.tag-'+data.id).remove();
												if(reloadGrid) {
													reloadGrid();
												}
											}
										},
										cache: false,
										contentType: false,
										processData: false
									});
								});
							}
						}
					}
				});


				break;
			case 'history':
				var table = content.append('table'),
					head = table.append('thead').append('tr'),
					body = table.append('tbody');
				head.append('th').text('Page');
				head.append('th').text('T');

				config.data.forEach(buildHistoryRow);


				body.append('span').append('a').attr('href', '#')
					.text("See more").on('click', function(){
					PathOS.history.more().forEach(buildHistoryRow);

					$(this).remove();
				});
				break;
			case 'established':
				content.remove();
				break;
			default:
				var ul = content.append("ul")
					.style('clip', "rect(0px, 1000px, 0px, 0px)");

				if(config.data instanceof Array) {
					config.data.forEach(function(d){
						ul.append("li").html(d);
					});
				} else {
					Object.keys(config.data).forEach(function(key){
						ul.append("li").html(key+": "+config.data[key]);
					});
				}
				break;
		}
	}

	if(div.classed('hide') || config.hide) {
		div.classed('hide', false);
		that.toggle(config.name);
	}

};

PathOS.module.prototype.toggle = function(item){

	if(d3.event) {
		d3.event.preventDefault();
	}
	var name = typeof item == 'string' ? item : d3.select(this).datum().name;

	var id = "#" + name;

	$(id).toggleClass("hidden");
	$(id+" i.minimise").toggleClass("fa-minus-square");
	$(id+" i.minimise").toggleClass("fa-plus-square");

	var height = $(id).height();

	if(d3.select(id).classed("hidden")) {
		d3.select(id).style("min-height", "1px");

		if(PathOS.user) {
			PathOS.modules.settings[PathOS.user].hide[name] = true;
			PathOS.data.save("modules", PathOS.modules.settings);
		}
	} else {
		d3.select(id).style("min-height", height + "px");

		if(PathOS.user) {
			delete PathOS.modules.settings[PathOS.user].hide[name];
			PathOS.data.save("modules", PathOS.modules.settings);
		}
	}
};

PathOS.module.prototype.data = function(){
	var d = d3.select(this).datum();
	console.log(d);
};

/**
 *
 * @type {{menuVisible: boolean, settings: {}, map: {}, init: PathOS.modules.init, menu: {show: PathOS.modules.menu.show, hide: PathOS.modules.menu.hide}}}
 */

PathOS.modules = {
	menuVisible: false,
	settings: {},
	map: {},
	init: function( options ) {
		//get settings if they exist, or use default settings

		console.log("loading module settings");

		// Load settings
		PathOS.modules.settings = PathOS.data.load("modules");

		PathOS.controller = options.controller;
		PathOS.action = options.action;

		// If user's settings exist...
		if (options.user) {
			PathOS.user = options.user;
			if (PathOS.modules.settings[PathOS.user]) {
				//set things like reordering tables and history
				Object.keys(PathOS.modules.settings[PathOS.user].hide).forEach(function (d) {
					if (document.getElementById(d) && !d3.select("#" + d).classed("hidden")) {

						if (PathOS.modules.map[d]) {
							PathOS.modules.map[d].object.toggle(d);
						} else {
							d3.select("#" + d).classed("hide", true);
						}

					}
				});


				if(PathOS.modules.settings[PathOS.user].sidebar[window.location.pathname]) {
					if (PathOS.modules.settings[PathOS.user].sidebar[window.location.pathname] == 'show') {
						d3.select("#wrapper").classed("toggled", false);
						d3.select("#sidebar-toggle i").classed("fa-chevron-left", false);
						d3.select("#sidebar-toggle i").classed("fa-chevron-right", true);
					} else if (PathOS.modules.settings[PathOS.user].sidebar[window.location.pathname] == 'hide') {
						d3.select("#wrapper").classed("toggled", true);
						d3.select("#sidebar-toggle i").classed("fa-chevron-left", true);
						d3.select("#sidebar-toggle i").classed("fa-chevron-right", false);
					}
				}










			} else {
				PathOS.modules.settings[PathOS.user] = {
					sidebar: {},
					hide: {},
					svlistIGV: "ask"
				};
				PathOS.data.save("modules", PathOS.modules.settings);
			}
		}



		d3.select("#sidebar-footer")
		.append('span')
		.append('a')
			.attr('href', '#')
			.on('click', function(){
				if(PathOS.modules.menuVisible) {
					PathOS.modules.menu.hide();
				} else {
					PathOS.modules.menu.show();
				}
			}).append('i')
			.attr('class', 'fa-lg fa fa-cog')
			.attr('aria-hidden', 'true');
	},
	menu: {
		show: function(){
			console.log("showing settings!");

			var menubox = d3.select('body')
				.append('div')
				.attr('id', 'overlay')
				.on('click', PathOS.modules.menu.hide)
			.append('div').on('click', function() { d3.event.stopPropagation(); })
				.attr('id', 'moduleMenu')
				.classed('fb-box', true);

			menubox.append('a').attr('href', '#').on('click', PathOS.modules.menu.hide)
				.append("i").classed("fa fa-close fa-lg", true);

			menu = menubox.append("div");

			header = menu.attr('id', 'mmHeader')
				.append('h1').text("PathOS Options");


			function deselectIGV(){
				d3.selectAll("#IGV-options a").classed("selected", false);
			}

			if(PathOS.user) {
				var igv = menu.append("p")
					.attr('id', "IGV-options")
					.text("IGV.js Options: ");

				igv.append("p").text("In-browser IGV (also known as IGV.js) can load in the background while you browse PathOS. It can also downsample reads, which will make larger runs easier for your computer to handle.");

				igv.append("a")
					.attr('href',"#")
					.attr('id', "svlist-igv-auto")
					.text("Auto Load (no downsampling)")
					.on("click", function(){
						deselectIGV();
						d3.select(this).classed("selected", true);
						PathOS.modules.settings[PathOS.user].svlistIGV = "auto";
						PathOS.data.save("modules", PathOS.modules.settings);
					});
				igv.append("a")
					.attr('href', "#")
					.attr('id',"svlist-igv-downsample")
					.text("Auto Load (downsample to 2500)")
					.on("click", function(){
						deselectIGV();
						d3.select(this).classed("selected", true);
						PathOS.modules.settings[PathOS.user].svlistIGV = "downsample";
						PathOS.data.save("modules", PathOS.modules.settings);
					});
				igv.append("a")
					.attr('href',"#")
					.attr('id', "svlist-igv-ask")
					.text("Ask Before Loading IGV.js")
					.on("click", function(){
						deselectIGV();
						d3.select(this).classed("selected", true);
						PathOS.modules.settings[PathOS.user].svlistIGV = "ask";
						PathOS.data.save("modules", PathOS.modules.settings);
					});


				if(PathOS.modules.settings[PathOS.user]) {
					var svlistIGV = PathOS.modules.settings[PathOS.user].svlistIGV;
					if (typeof svlistIGV  == 'undefined' || svlistIGV == 'ask') {
						d3.select("#svlist-igv-ask").classed("selected", true);
					} else if (svlistIGV == 'downsample' ) {
						d3.select("#svlist-igv-downsample").classed("selected", true);
					} else if (svlistIGV == 'auto' ) {
						d3.select("#svlist-igv-auto").classed("selected", true);
					}
				}


				menu.append("p")
					.text("PathOS History: ")
				.append("a")
					.text("Clear History")
					.attr("href", "#")
					.attr('id', 'clearHistory')
					.on("click", function(){
						PathOS.data.clear("history");
						alert("History Cleared!");
					});
			}

			var links = menu.append('p').attr('id','pathos-menu-links').text("Links to: ");

			links.append("a")
				.attr('href', "https://115.146.86.118/jira/secure/Dashboard.jspa")
				.text("Jira");
			links.append("span").text(" - ");
			links.append('a').attr('href', 'https://115.146.86.118/confluence/display/PVS/PathOS+Variant+System').text("Confluence");
			links.append("span").text(" - ");
			links.append('a').attr('href', 'http://pathos.co/help').text("Help");


			//Turn off hotkeys, and make "esc" hide the menu
			PathOS.hotkeys.off();
			$('body').on('keydown', function(e){
				if(e && e.keyCode && e.keyCode == 27 && !$(document.activeElement).is("input") && !$(document.activeElement).is("textarea") && !e.altKey && !e.metaKey && !e.ctrlKey){
					PathOS.modules.menu.hide();
				}
			});
		},
		hide: function(){
			console.log("hiding settings!");

			// Get rid of the menu
			d3.select("#overlay").remove();
			// Bring back the hotkeys...
			PathOS.hotkeys.init();

		}
	}
};


/**
 * This bundle is for the svlist page and showing Curated Variants
 *
 * DKGM 21-October-2016
 *
 * @type {{showCV: PathOS.svlist.showCV, closeCV: PathOS.svlist.closeCV}}
 */

PathOS.svlist = {
	evidence: {
		'pathAloneTruncating':"Truncating variant (nonsense, frameshift, canonical splice site, initiation codon) in a known tumour suppressor gene",
		'pathAloneKnown':"Same missense change as a previously established pathogenic variant",
		'pathStrongFunction':"Well-established in vitro or in vivo functional studies support a deleterious effect on the gene or gene product",
		'pathStrongCase':"Case-control studies show enrichment in cases",
		'pathStrongCoseg':"<b><i>For familial cancer only:</i></b> Proband's family study shows co-segregation with cancer",
		'pathSupportHotspot':"Located near a known mutational hot-spot or within a well-characterised functional domain",
		'pathSupportGene':"Occurs in a gene with high clinical specificity and sensitivity for the cancer",
		'pathSupportInsilico':"Multiple types of computational evidence support a deleterious effect on the gene or gene product (PolyPhen, SIFT, Mutation Taster ,conservation, evolution, splicing)",
		'pathSupportSpectrum':"Type of variant fits known mutation spectrum for the gene",
		'pathSupportGmaf':"Absent from ESP and 1000 Genomes data, or frequency is below highest global minor allele frequency (GMAF) expected for autosomal dominant disease (0.4%)",
		'pathSupportIndel':"In-frame deletion/insertion in a well characterised functional domain",
		'pathSupportNovelMissense':"Novel missense change at an amino acid where a different missense change is pathogenic",
		'pathSupportLsdb':"Noted as pathogenic in a curated locus specific database",
		'pathSupportCoseg':"<b><i>For familial cancer only:</i></b> Proband's family study shows co-segregation with disease",
		'benignAloneGmaf':"Exists in ESP and 1000 Genomes >= 0.4% GMAF",
		'benignAloneHealthy':"<b><i>For familial cancer only:</i></b> For a fully penetrant cancer syndrome, observed in a healthy adult individual",
		'benignStrongFunction':"Well-established in vitro or in vivo functional studies shows no deleterious effect on protein function or splicing",
		'benignStrongCase':"Case control studies show comparable frequencies",
		'benignStrongCoseg':"<b><i>For familial cancer only:</i></b> Variant fails to co-segregate with disease in a family study",
		'benignSupportVariable':"Located in a region without a characterised function or away from known mutation hot-spots",
		'benignSupportInsilico':"Multiple types of computational evidence suggest no impact on gene or gene product (PolyPhen, SIFT, Mutation Taster, conservation, evolution, splicing)",
		'benignSupportSpectrum':"Type of variant does not fit known mutation spectrum for the gene",
		'benignSupportLsdb':"Noted as benign in a curated locus specific database",
		'benignSupportPath':"<b><i>For familial cancer only:</i></b> For a fully penetrant cancer syndrome, observed with another pathogenic variant in the same individual"
	},
	// Clin Context Comparitor
	// DKGM 18-Nov-2016
	// Rewrite this better. This is just hacked for a demo.
	ccc: function(a, b) {
		var result = false;
		if (a === null || b === null) {
			if (a === null && b === null) {
				result = true;
			}
		} else {
			if (a.id == b.id) {
				result = true;
			}
		}
		return result;
	},
	createCV: function ( sv ) {
		console.log("Ok, I guess we're making a CV now...");
		console.log("Your sv is: "+sv);
		console.log(this);

		var cc = $("#newCVcc").val();

		var params = {
			id: sv,
			cc: cc
		};
		$.ajax({
			type: "POST",
			url: "/PathOS/CurVariant/newCV?" + $.param(params),
			success: function (d) {
				if (typeof d == "string") {
					alert(d);
				} else {
					console.log(d);
				}
			},
			cache: false,
			contentType: false,
			processData: false
		});
	},
	saveCV: function ( cv ) {
		var report = 'fail';
		var evidence = 'lol';

		report = $("#cv-"+cv+" .report").val();
		evidence = $("#cv-"+cv+" .evidence").val();


		var params = {
			id: cv,
			report: report,
			evidence: evidence
		};
		$.ajax({
			type: "POST",
			url: "/PathOS/CurVariant/updateCV?" + $.param(params),
			success: function (d) {
				if (typeof d == "string") {
					alert(d);
				} else {
					console.log(d);
					//if (div.select(".tag-"+ d.id).empty()) {
					//	PathOS.tags.drawTag(div, d, true);
					//	$('#tag_text_area').val('');
					//}
				}
			},
			cache: false,
			contentType: false,
			processData: false
		});

		console.log("Trying to save: "+cv);
		console.log("report is: "+report);
		console.log("evidence is: "+evidence);
	},

	/**
	 * DKGM 21-November-2016
	 *
	 * Call this function from the svlist page to build an overlay.
	 * The overlay will show all Curated Variants for a specified Sequenced Variant.
	 *
	 * Build the overlay, then do an ajax call for the information.
	 * Key info:
	 * - SeqVariant info
	 * - List of Curated Variants
	 *
	 * @param sv
     */

	showCVs: function( sv ) {
		console.log("Showing all Curated Variants for this Sequenced Variant");


// Build the Overlay
		var cvbox = d3.select('body')
			.append('div')
			.attr('id', 'overlay')
			.on('click', PathOS.svlist.closeCV)
			.append('div').on('click', function() { d3.event.stopPropagation(); })
			.attr('id', 'show-cv')
			.classed('fb-box', true)
			.classed("container", true);

		cvbox.append('a').attr('href', '#').on('click', PathOS.svlist.closeCV)
			.append("i").classed("fa fa-close fa-lg", true);

		var cvdiv = cvbox.append("div");

		cvdiv.append("img")
			.classed("loading_logo", true)
			.attr("id", "cv-loading")
			.attr("src", "/PathOS/dist/img/pathos_logo_animated.svg");

		$.ajax("/PathOS/SeqVariant/lookUpCVs?id="+sv, {success:function(d){
			d3.select("#cv-loading").remove();
			console.log(d);

			var header = cvdiv.attr('id', 'cvHeader')
				.append('h1').text("Sequenced Variant: "+ d.sv.hgvsc);

			console.log( "SV id is: " + sv );

			var infobox = cvdiv.append("div")
				.attr("id", "sv-info")
				.classed("row", true);

			//infobox.append("div")
			//	.classed("fb-box", true)
			//	.append("h2")
			//	.text("Info to go in here");
// Add info about the seqvariant
//
			var seqVarBox = infobox.append("div")
				.classed("fb-box", true)
				.classed("col-xs-5 col-xs-offset-1", true)
				.attr("id", "sv-infobox-div");

			seqVarBox.append("h2").text("Sequenced Variant information:");

			svClinContext = "None";
			if (d.sv.clinContext) {
				svClinContext = d.lookup.context(d.sv.context.id);
			}
			var box1 = {
				"Gene": d.sv.gene,
				"HGVSC": d.sv.hgvsc,
				"HGVSG": d.sv.hgvsg,
				"HGVSP": d.sv.hgvsp,
				"Clinical Context (from sample)": svClinContext,
				"Consequences": d.sv.consequence,
				"Variant Caller": d.sv.varcaller,
				"Amplicon Count": d.sv.numamps,
				"Amplicon Bias": d.sv.ampbias
			};
			var box2 = {
				"Variant Frequency": d.sv.varFreq,
				"Variant Depth": d.sv.varDepth,
				"Panel Var %": d3.format(".4")(d.sv.varPanelPct)+"%",
				"dbSNP": d.sv.dbsnp,
				"GMAF %": d.sv.gmaf,
				"ESP %": d.sv.esp,
				"ExAC %": d.sv.exac,
				"Cosmic": d.sv.cosmic ? "<a target='_blank' href='/PathOS/seqVariant/cosmicAction?id='"+ d.sv.id+" title='"+ d.sv.cosmicOccurs+"'>COSM"+ d.sv.cosmic+"</a>" : "",
				"Exon": d.sv.exon,
				"Cytoband": d.sv.cytoband,
				"CADD Raw": d3.format("(.2f")(d.sv.cadd),
				"CADD Scaled": d3.format("(.2f")(d.sv.cadd_phred)
			};

			drawTable(box1, seqVarBox);

			var otherBox = infobox.append("div")
				.classed("fb-box", true)
				.classed("col-xs-5", true)
				.attr("id", "cv-infobox-div");

			drawTable(box2, otherBox);

// Add info about the Preferred Curated Variant
//			var preferredCVbox = infobox.append("div")
//				.classed("fb-box", true)
//				.classed("col-xs-3", true)
//				.attr("id", "cv-infobox-div");
//			preferredCVbox.append("h2").text("Curated Variant Information:");
//
//			svClinContext = "None";
//			if (d.sv.clinContext) {
//				svClinContext = d.lookup.context(d.sv.context.id);
//			}
//
//			var tempPmClass = null;
//			if (d.preferred && d.preferred.pmClass) {
//				tempPmClass = d.preferred.pmClass;
//			}
//
//			var preferredData = {
//				"Classification": tempPmClass,
//				"Classified By": d.lookup.classified,
//				"Authorised By": d.lookup.authorised,
//				"Or maybe": "The person who classified this variant",
//				"And also": "The people who verified it"
//			};
//			drawTable(preferredData, preferredCVbox);
//
//
//
//			var buttons = infobox.append("div")
//				.attr("id", "cv-buttons")
//				.classed("xs-col-4", true)
//				.classed("fb-box", true);
//
//
//			var newCV = buttons.append("div").classed("fb-box", true);
//
//			newCV.append("h4").text("Add a new CV");
//			newCV.append("input")
//				.attr("id", "newCVcc")
//				.attr("placeholder", "Pick a Clinical Context");
//
//			var ccArray = [];
//			d.lookup.listOfCC.forEach(function(cc){
//				ccArray.push(cc.description);
//			});
//			console.log(ccArray);
//
//			$("#newCVcc").autocomplete({source: ccArray});
//
//			newCV.append("a")
//				.attr("href","#none")
//				.attr("onclick", "PathOS.svlist.createCV("+ d.sv.id+")")
//				.text("Create a new CV");
//
//
//
//
//
//
//			buttons.append("a").attr("href","#na").text("Add new CV").classed("cv-button", true);
//			buttons.append("br");
//			buttons.append("a").attr("href","#na").text("Another button to do another thing").classed("cv-button", true);
//			buttons.append("br");
//			buttons.append("a").attr("href","#na").text("More buttons!").classed("cv-button", true);



			cvdiv.append("h1").text("Curated Variants:");
			var row = cvdiv.append("div")
				.classed("row", true)
				.attr("id", "cv-list");

			var table = row.append('table');

			var thead = table.append("thead").append("tr");

			thead.append("th").text("Context").style("width", "15%");
			thead.append("th").text("Report Description");
			thead.append("th").text("Evidence Description");
			thead.append("th").text("Classification");

			var tbody = table.append("tbody");
			var cv = null;
			var evidence = null;
			if(d.generic) {
				if(d.currentCV && d.currentCV.id != d.generic.id) {
					addCVrow(d.generic, false);
					addCVrow(d.currentCV, true);
				} else {
					addCVrow(d.generic, true);
				}
			}
			d.otherCVs.forEach(function(data){
				addCVrow(data, false);
			});

			function addCVrow(data, highlight){
				var label = "Generic",
					id = data.id;
				if(data.clinContext) {
					label = d.lookup.context[data.clinContext.id];
				}
				cv = tbody.append("tr")
					.classed("current-context-cv", highlight);
				if(highlight){
					cv.append("td").append("h2").html("Current Context<br>")
						.append("a")
						.attr("href", "/PathOS/curVariant/show?id=" + data.id)
						.text(label);
				} else {
					cv.append("td")
						.append("a")
						.attr("href", "/PathOS/curVariant/show?id=" + data.id)
						.text(label);
				}
				cv.append("td").append("textarea").attr("readonly", true).style("width", "100%").text(data.reportDesc);
				cv.append("td").append("textarea").attr("readonly", true).style("width", "100%").text(data.evidence.justification);

				evidence = cv.append("td");

				var pmClass = data.pmClass.split(":")[0];
				evidence.append("p")
					.text(data.pmClass)
					.classed("cvlabel cv-"+pmClass, true);

				var count = 0;

				var button = evidence.append("a")
					.attr("href", "#none")
					.on("click", function(d){
						console.log("cliccckinggggg");
						$("#evidence-list-"+id).toggleClass("hidden");
					});

				var list = evidence.append("ul")
					.attr("id", "evidence-list-"+id)
					.classed("hidden", true);

				Object.keys(PathOS.svlist.evidence).forEach(function(key){
					if(data.evidence[key]) {
						count++;
						list.append('li').html(PathOS.svlist.evidence[key]);
					}
				});
				button.text("Show Evidence ("+count+")");
			}








            //
            //
            //
			//var name = row.append("div").classed("col-xs-1 fb-box", true);
            //
			//var left = row.append("div").classed("col-xs-3 fb-box", true);
            //
			//var middle = row.append("div").classed("col-xs-3 fb-box", true);
            //
			//var right = row.append("div").classed("col-xs-5 fb-box", true);
            //
			//name.append("h4").text("Name")
			//	.classed("cv-header", true);
			//left.append("h4").text("Generic Curated Variant")
			//	.classed("cv-header", true);
			//middle.append("h4").text("Preferred Curated Variant")
			//	.classed("cv-header", true);
            //
			//right.append("h4").text("Other Curated Variants")
			//	.classed("cv-header", true);
            //
            //
            //
			//name.append("div").append("p").text("Clinical Context").classed("cc-header", true);
			//name.append("div").append("p").text("Report Description").classed("report", true);
			//name.append("div").append("p").text("Evidence").classed("evidence", true);
            //
            //
            //
			//drawCVs(
			//	left, //.append("table").append("tbody").append("trow").append("td").append("div"),
			//	d.generic,
			//	d.lookup
			//);
            //
			//drawCVs(
			//	middle, //.append("table").append("tbody").append("trow").append("td").append("div"),
			//	d.preferred,
			//	d.lookup
			//);
            //
			//var otherCVs = right.append("table").append("tbody").append("trow");
			//d.otherCVs.forEach(function(cv){
			//	drawCVs(
			//		otherCVs.append("td").classed("cv-td", true).append("div"),
			//		cv,
			//		d.lookup
			//	);
			//});
            //



		}});

		function drawCVs(div, cv, lookup) {
			console.log(cv);

			div.attr("id", "cv-"+cv.id);

			var cc = "Generic";
			if (cv.clinContext !== null) {
				cc = lookup.context[cv.clinContext.id];
			}

			// Clinical Context...
			div.append("div")
				.append("p")
				.text(cc);

			div.append("a")
				.attr("href","#na")
				.attr("onclick", "PathOS.svlist.saveCV("+ cv.id +")")
				.text("Save CV")
				.classed("cv-button", true);

			// Report Description...
			div.append("div")
				.append("textarea")
				.classed("report", true)
				.html(cv.reportDesc);

			// Evidence Justification...
			div.append("div")
				.append("textarea")
				.classed("evidence", true)
				.html(cv.evidence.justification);
		}

		function drawTable(info, infobox){
			infobox.select("table").remove();

			var table = infobox.append("table")
				.attr("id", "svInfoTable")
				.classed("infoTable", true);

			var tbody = table.append("tbody");

			Object.keys(info).forEach(function(row){
				var r = tbody.append("tr");
				r.append("td").html(row).classed("property-label", true);
				r.append("td").html(info[row]).classed("property-value", true);
			});
		}




		//Turn off hotkeys, and make "esc" hide the menu
		PathOS.hotkeys.off();
		$('body').on('keydown', function(e){
			if(e && e.keyCode && e.keyCode == 27 && !$(document.activeElement).is("input") && !$(document.activeElement).is("textarea") && !e.altKey && !e.metaKey && !e.ctrlKey){
				PathOS.svlist.closeCV();
			}
		});
	},
	closeCV: function(){
		console.log("closing CV!");

		// Get rid of the menu
		d3.select("#overlay").remove();
		// Bring back the hotkeys...
		PathOS.hotkeys.init();

	}
};
















PathOS.buildBlock = function (div, data){
	data.forEach(function(d){
		var line = div.append('p');

		if(d.link && d.link !== '') {
			line.append('span').classed('bold', true).text(d.title+": ");
			line.html(line.html()+'<a href="'+d.link+'">'+ d.words+'</a>');
		} else {
			line.append('span').classed('bold', true).text(d.title+": ");
			line.html(line.html()+d.words);
		}
	});
};



PathOS.classify = function (d){
	return d.toLowerCase().replace(" ", "-");
};

PathOS.params = function() {
	var params = {};
	var string = window.location.search.substring(1);
	var arr = string.split("&");

	arr.forEach(function(q){
		if(q.indexOf("=") > 0) {
			var stuff = q.split("="),
				name = stuff[0],
				data = decodeURIComponent(stuff[1].replace(/\+/g, " "));

			params[name] = data;
		}
	});

	return params;
};

PathOS.evidence = {
	benignAloneGmaf: "Benign Stand-alone Gmaf",
	benignAloneHealthy: "Benign Stand-alone Healthy",
	benignStrongCase: "Benign Stand-alone Strong-case",
	benignStrongCoseg: "Benign Stand-alone Coseg",
	benignStrongFunction: "Benign Strong Function",
	benignSupportInsilico: "Benign Support Insilico",
	benignSupportLsdb: "Benign Support Local Sequence Database",
	benignSupportPath: "Benign Support Pathology",
	benignSupportSpectrum: "Benign Support Spectrum",
	benignSupportVariable: "Benign Support Variable",
	pathAloneKnown: "Pathology Stand-alone Known",
	pathAloneTruncating: "Pathology Stand-alone Truncating",
	pathStrongCase: "Pathology Strong Case",
	pathStrongCoseg: "Pathology Strong Coseg",
	pathStrongFunction: "Pathology Strong Function",
	pathSupportCoseg: "Pathology Support Coseg",
	pathSupportGene: "Pathology Support Gene",
	pathSupportGmaf: "Pathology Support Gmaf",
	pathSupportHotspot: "Pathology Support Hotspot",
	pathSupportIndel: "Pathology Support Indel",
	pathSupportInsilico: "Pathology Support Insilico",
	pathSupportLsdb: "Pathology Support Local Sequence Database",
	pathSupportNovelMissense: "Pathology Support Novel Missense",
	pathSupportSpectrum: "Pathology Support Spectrum"
};


// Add hotkeys to any PathOS page.
// init is called once in layouts/main.gsp
// use PathOS.hotkeys.off(); to turn off the hotkeys on a page.
 PathOS.hotkeys = {
 	keys: {
		27: function(){
			d3.selectAll(".tagdiv .tooltip.edit").classed("edit", false);
		}
	},
 	add: function(key, action){
 		this.keys[key] = action;
 	},
 	off: function(){
 		$('body').off("keydown");
 	},
 	init: function(){
 		var keys = this.keys;
		$('body').on("keydown", function(e){
			if(e && e.keyCode && keys[e.keyCode] && !$(document.activeElement).is("input") && !$(document.activeElement).is("textarea") && !e.altKey && !e.metaKey && !e.ctrlKey){
					keys[e.keyCode]();
			}
		});
 	},
 	testMode: function(){
 		var keys = this.keys;
		$('body').on("keydown", function(e){
			if(e && e.keyCode && !$(document.activeElement).is("input") && !e.altKey && !e.metaKey && !e.ctrlKey){
					console.log("You pushed: "+e.keyCode);
				if (keys[e.keyCode]) {
					console.log("It has this function:");
					console.log(keys[e.keyCode]);
				}
			}
		}); 
 	}
 };


PathOS.timeSince = function (date) {
	var val = "",
		d = Date.parse(date),
		c = Date.now(),
		i = c - d;

	if( d > 0 ) {
		if (i < 3600000 ) {
			val = Math.floor(i / 60000) + "m";
		} else if (i < 86400000 ) {
			val = Math.floor(i / 3600000) + "h";
		} else {
			val = Math.floor(i / 86400000) + "d";
		}
	}

	return val;
};




// This function adds a checkbox to your page that uses local storage
// The option will persist over screen refreshes.
// This allows us to flip a class on a set of things.
// Very useful for changing colours or hiding elements.
//
// div = where you want the checkbox to go
// label = the label of the checkbox
// key = the class that we look for, which we put a toggle on.
// 		The added class will be called "key"-toggle
// value = default value of the checkbox (optional, default is false)


PathOS.addOption = function(div, label, key, value){
	var checkbox = div.append('label');
	checkbox.append('input')
		.attr('class', 'option')
		.attr('id', 'option-'+key)
		.attr('type', 'checkbox');
	checkbox.html(checkbox.html()+" "+label+"<br>");
	checkbox.on('change', function(){
		$('.'+key).toggleClass(key+'-toggle');
		localStorage[key+'-option'] = document.getElementById("option-"+key).checked;
	});


	// Set it to true if the default is true or if the flag has been set to true.
	if(value) {
		if(typeof localStorage[key+'-option'] == 'undefined' ||
				localStorage[key+'-option'] === true ||
				localStorage[key+'-option'] == 'true'
		){
			checkbox.select('input').attr('checked', value);
			d3.selectAll('.'+key).classed(key+'-toggle', true);
		}
	} else {
		if(typeof localStorage[key+'-option'] != 'undefined' &&
			localStorage[key+'-option'] === true ||
			localStorage[key+'-option'] == 'true'
		){
			checkbox.select('input').attr('checked', true);
			d3.selectAll('.'+key).classed(key+'-toggle', true);
		}
	}
	// The logic here could probably be more elegant, but I cbf thinking right now.

};

PathOS.history = {
	json: [],

	/**
	 * Add a webpage to the history
	 *
	 * example:
	 * PathOS.history.add({
	 *	title: document.title,
	 *	url: window.location.href,
	 *	time: Date()
	 * @param title, url, time
     */
	add: function (d){
		PathOS.history.json.forEach(function(old, i){
			if(old.title == d.title){
				PathOS.history.json.splice(i, 1);
			}
		});
		PathOS.history.json.push(d);
		if(PathOS.history.json.length > 50) {
			PathOS.history.json = PathOS.history.json.slice(20);
		}
		PathOS.data.save("history", PathOS.history.json);
	},
	clear: function() {
		PathOS.history.json = [];
		PathOS.data.clear("history");
	},
	show: function(d) {
		var arr = PathOS.history.json;
		var n = d || 10;
		return (arr.length < n ? arr : arr.slice(arr.length - n)).reverse();
	},
	more: function() {
		var arr = PathOS.history.json;
		var n = 50;

		return (arr.length < n ? arr : arr.slice(arr.length - n)).reverse().slice(10);
	},
	init: function(){
		PathOS.history.json = PathOS.data.load("history", []);
	}
};

/* Initialise stuff, like:
 * Hotkeys,
 * History
 *
 *
 *
 *
 *
 */



// Saftey is for stopping people leaving the page if they've typed stuff.
// To be implimented
PathOS.safety = {
	change: false,
	saved: false,
	init: function(){
		$('textarea,input').keyup(function(){
			PathOS.safety.change = true;
		});

		$('.savebutton').on('click',function(){
			PathOS.safety.saved = true;
		});

		window.onbeforeunload = function() {
			if(PathOS.safety.change && !PathOS.saftey.saved) {
				return 'Testing';
			}
		};
	}
};

// This part of the PathOS library will be used to build a standardised tag system
// Perhaps a taglib might be more appropriate? I'm not sure which is better.
// I'm just going to get it working first, then optimise later.
// DKGM 30 June 2016
PathOS.tags = {
	current_object: false,
	update_object: function(d) {
		PathOS.tags.current_object = d;
		var params = {
			type: PathOS.controller,
			id: d
		};
		if(params.type && d) {
			$.ajax({
				type: 'GET',
				url: "/PathOS/tag/getTags?" + $.param(params),
				success: function (d){
					console.log(d);
					d3.select("#tags").style('display','');
					$("#object_id").text(d.name);
					d3.selectAll("#tags .tagdiv").remove();
					if(d.tags) {
						d.tags.forEach(function(tag){
							PathOS.tags.drawTag(d3.select("#tags .fb-box"), tag, true);
						});
					} else {
						PathOS.tags.nullObject(d3.select("#tags .fb-box"));
						//alert("Can't find tags on an unsaved object");
					}
				},
				cache: false,
				contentType: false,
				processData: false
			});
		}
	},
	buildModule: function(data){
		console.log('Building tags module.');
		var tags = new PathOS.module({
			name: "tags",
			title: "Tags",
			type: "tags",
			data: data,
			closeModule: data.closeModule
		});
	},
	nullObject: function (div) {
		div.insert("div",":first-child").classed("tagdiv", true).append("label").text("You cannot add tags to it.");
		div.insert("div",":first-child").classed("tagdiv", true).append("label").text("Sorry, this object has not be saved.");
	},
	drawTagById: function(box, id, deletable) {
		$.ajax("/PathOS/Tag/lookUp?id="+id, {success: function(data){
			PathOS.tags.drawTag(box, data, deletable);
		}});
	},
	drawTag: function ( box, data, deletable ) {
		if (data == "fail") {
			alert("Sorry, you cannot set a reserved smart tag");
		} else {
			var div = data.isAuto ? box.insert('div', ':first-child'): box.insert('div', 'textarea');

			div.attr('class', "tagdiv tag-"+data.id)
				.datum(data)
				.classed("isAuto", data.isAuto)
				.on('click', function(d){
					var that = this;

					// If we're editing, and it's not auto, we need to delete this tag.
					if(!d.isAuto && d3.select("#tags").classed("editing")) {
						// DELETE TAG!!!
						var params = {
							type: PathOS.controller,
							objid: PathOS.tags.current_object,
							tagid: d.id
						};
						$.ajax({
							type: "DELETE",
							url: "/PathOS/tag/removeLink?" + $.param(params),
							success: function (result) {
								if(result != 'fail') {
									$(that).remove();
									if(reloadGrid) {
										reloadGrid();
									}
								}
							},
							cache: false,
							contentType: false,
							processData: false
						});
					} else {
						// Otherwise, redirect to the search page.
						d3.select(that).select(".tooltip").classed("dismiss", true);
					}
				});

			div.append('span').text(data.label);


			var text = data.description || "Enter Description Here.";
			var tooltip = div.append('div').classed('tooltip fb-box', true);

			tooltip.append("button").text("Search").on("click",function(d){
				d3.event.stopPropagation();
				window.location.href = "/PathOS/search?q="+d.label;
			});

			tooltip.append("button").text("View").on("click",function(d){
				d3.event.stopPropagation();
				window.location.href = "/PathOS/Tag/Show/"+d.id;
			});

			tooltip.append("button").text("Edit").on("click", function(d){

			});


			tooltip.append('i').classed('fa fa-close fa-lg', true).on('click', function(){
				d3.event.stopPropagation();
				tooltip.classed("edit", false);
			});

			if (deletable) {
				tooltip.append('i').classed('fa fa-trash fa-lg', true).on('click', function(){
					d3.event.stopPropagation();
					if(confirm('Remove tag "'+data.label+'" from this object?')) {
						var params = {
							type: PathOS.controller,
							objid: PathOS.tags.current_object,
							tagid: data.id
						};
						$.ajax({
							type: "DELETE",
							url: "/PathOS/tag/removeLink?" + $.param(params),
							success: function (result) {
								if(result != 'fail') {
									$('.tag-'+data.id).remove();
									if(reloadGrid) {
										reloadGrid();
									}
								}
							},
							cache: false,
							contentType: false,
							processData: false
						});
					}
				});
			}

			tooltip.append('i').classed('fa fa-check fa-lg', true).on('click', function(){
				d3.event.stopPropagation();
				tooltip.classed("dismiss", false);
			});

			//var text = data.description === "" ? "Enter Description Here." : data.description;
			tooltip.append('p').classed("tt_description", true).text(text);
			tooltip.append('input').attr('value', text).on("keydown", function(){
					var e = d3.event;
					if(e && e.keyCode && e.keyCode == 13) {
						var params = {
							description: $(this).val(),
							id: data.id
						};
						$.ajax("/PathOS/Tag/putDescription?"+ $.param(params), {
							success: function(){
								$(".tag-"+data.id+" input").val(params.description);
								$(".tag-"+data.id+" p").text(params.description);
								tooltip.classed("edit", false);
								tooltip.classed("dismiss", true);
								if(reloadGrid) {
									reloadGrid();
								}
							}
						});
					}
				});



			tooltip.on("click", function(d){
				d3.event.stopPropagation();
				tooltip.classed("edit", true);
			});
		}
	},
	addTag: function (div, tag, controller, id) {
		if( typeof controller == 'undefined') {
			controller = PathOS.controller;
		}
		if( typeof id == 'undefined' ){
			id = PathOS.tags.current_object;
		}
		if( controller && tag && id ) {
			var params = {
				type: controller,
				id: id,
				tag: tag,
				user: PathOS.user
			};
			$.ajax({
				type: "POST",
				url: "/PathOS/tag/addTag?" + $.param(params),
				success: function (d) {
					if (typeof d == "string") {
						alert(d);
					} else {
						if (div.select(".tag-"+ d.id).empty()) {
							PathOS.tags.drawTag(div, d, true);
							$('#tag_text_area').val('');
							if(reloadGrid) {
								reloadGrid();
							}
						}
					}
				},
				cache: false,
				contentType: false,
				processData: false
			});
		} else {
			console.log("We don't have a controller, tag or id.");
			console.log(controller);
			console.log(tag);
			console.log(id);
		}
	}
};



PathOS.printQC = function(data) {
	var label = data.div.append("h4")
				.classed("flag", true);

	if(data.authorised === null) {
		label.text("QC Not Set").classed("unknown", true);
	} else if (data.passfailFlag) {
		label.text("QC Passed").classed("passed", true);
	} else if (!data.passfailFlag) {
		label.text("QC Failed");
	}

    //
    //
	//if(data.passfailFlag) {
	//	qcLabel.text("QC Passed").classed("passed", true);
	//} else {
	//	qcLabel.text("QC Failed");
	//}
    //
	//console.log("data is: ");
	//console.log(data);
	//if(data.authorisedQc === null) {
	//	authorisedLabel.text("QC Authorisation Not Set").classed("unknown", true);
	//} else if (data.authorisedQcFlag) {
	//	authorisedLabel.text("QC Authorised").classed("passed", true);
	//} else if (!data.authorisedQcFlag) {
	//	authorisedLabel.text("QC Not Authorised");
	//}
};




// This code is for controlling IGV.js
// DKGM 31-August-2016

PathOS.igv = {
	loaded: false,
	options: {},
	init: function(igvDiv, dataUrl, sample, panel, samplingDepth) {

		var baiUrl = dataUrl+sample+".bai",
			bamUrl = dataUrl+sample+".bam",
			vcfUrl = dataUrl+sample+".vcf";

		var baseUrl = dataUrl.split("Pathology")[0],
			panelBedUrl = baseUrl + "Panels/" + panel + "/Amplicon.bed",
			panelTsvUrl = baseUrl + "Panels/" + panel + "/Amplicon.tsv";

		PathOS.igv.div = igvDiv;
		PathOS.igv.options = {
			showKaryo: "hide",
			showNavigation: true,
			showCenterGuide: true,
			reference: {
				fastaURL: "//dn7ywbm9isq8j.cloudfront.net/genomes/seq/hg19/hg19.fasta", //perhaps we should change this to a peter mac hosted hg19?
				indexFile: "/PathOS/igv/hg19.fasta.fai",
				cytobandURL: "/PathOS/igv/cytoBand.txt",
				order: -9999 // This is overridden... you can't set it.... it gets defaulted to -9999, so let's set the order of the other tracks around this value.
			},
			tracks: [
				{
					url: vcfUrl,
					type: "vcf",
					label: "VCF: "+sample,
					order: -10001
				},
				new PathOS.igv.BAM(baiUrl, bamUrl, sample, samplingDepth),
				{
					name: panel,
					url: panelBedUrl,
					indexURL: panelTsvUrl,
					displayMode: "EXPANDED",
					order: -9998
				},
				{
					url: '/PathOS/igv/hg19-RefSeqGenes.gtf.gz',
					indexURL: '/PathOS/igv/hg19-RefSeqGenes.gtf.gz.tbi',
					name: 'hg19 - Gencode v24',
					format: 'gtf',
					order: -9997,
					visibilityWindow: 10000000
				}
			]
		};

	},
	search: function(locus) {
		if(!PathOS.igv.loaded) { // First load! Let's do init stuff
			PathOS.igv.loaded = true;
			igv.createBrowser(PathOS.igv.div, PathOS.igv.options);
			$("#footer-message").remove();
		}
		// Browse to the locus that the user wants to see
		igv.browser.search(locus);
	},
	addBAM: function(sample, dataUrl, samplingDepth) {
		if(sample && dataUrl) {
			var baiUrl = dataUrl+sample+".bai",
				bamUrl = dataUrl+sample+".bam";
			var newTrack = new PathOS.igv.BAM(baiUrl, bamUrl, sample, samplingDepth);

			if(PathOS.igv.loaded) {
				igv.browser.loadTrack(newTrack);
			} else {
				PathOS.igv.options.tracks.push(newTrack);
			}
		} else {
			alert("There was an error, data not found.");
		}
	},
	BAM: function(baiUrl, bamUrl, sample, samplingDepth){

		// If samplingDepth is not provided, set  it to 2500.
		// This is currently used in seqrun/show.gsp
		samplingDepth = samplingDepth || 2500;

		this.indexURL = baiUrl;
		this.url = bamUrl;
		this.label = sample;
		this.type = "bam";
		this.alignmentRowHeight = 1;
		this.maxRows = 99999;
		this.order = -10000;
		this.height = 500;
		this.autoHeight = true;
		this.samplingDepth = samplingDepth;
		this.colorBy = "strand";
		this.negStrandColor = "rgb(150, 150, 230)";
		this.posStrandColor = "rgb(230, 150, 150)";
		this.deletionColor = "black";
		this.skippedColor = "rgb(150, 170, 170)";

		return this;
	}
};







PathOS.init = function(options){
	PathOS.modules.init(options);
	PathOS.hotkeys.init();
	PathOS.history.init();
	//PathOS.safety.init();
};




























//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJzY3JpcHRzLm1pbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTYW1wbGUgalF1ZXJ5IHBsdWdpbiBwYXR0ZXJuXG5cbi8vIChmdW5jdGlvbiAoJCwgd2luZG93KSB7XG5cbi8vIFx0JC5zYW1wbGVQbHVnaW4gPSBmdW5jdGlvbihlbGVtKSB7XG4vLyBcdFx0dmFyIGJhc2UgXHQ9IHRoaXM7XG4vLyBcdFx0YmFzZS4kZWxlbSBcdD0gJChlbGVtKTtcblxuLy8gXHQkLmZuLnNhbXBsZVBsdWdpbiA9IGZ1bmN0aW9uKCkge1xuLy8gXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuLy8gXHRcdFx0dmFyIHNhbXBsZVBsdWdpbiA9IG5ldyAkLnNhbXBsZVBsdWdpbih0aGlzKTtcbi8vIFx0XHR9KTtcbi8vIFx0fTtcblxuLy8gfSAoalF1ZXJ5LCB3aW5kb3cpKTtcbnZhciBQYXRoT1MgPSBQYXRoT1MgfHwge307XG5cblBhdGhPUy52ZXJzaW9uID0gXCJQYXRoT1MuanMgYnVpbGQ6IDI2dGggb2YgTWF5IDIwMTZcIjtcblxuXG4vLyBTaW1wbGUgd2F5IGZvciBQYXRoT1MgdG8gc3RvcmUgZGF0YVxuLy8gQ3VycmVudGx5IHVzZXMgbG9jYWxTdG9yYWdlIGJ1dCBjb3VsZCBiZSB1cGdyYWRlZCBpbiBmdXR1cmUuXG4vLyBES0dNIDI4LTA2LTIwMTZcblBhdGhPUy5kYXRhID0ge1xuXHQvLyBQcm92aWRlIGEga2V5IGFuZCBhIGRlZmF1bHQgb2JqZWN0XG5cdGxvYWQ6IGZ1bmN0aW9uKGtleSwgb2JqKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG9iaiB8fCB7fTtcblx0XHRpZiAobG9jYWxTdG9yYWdlW1wiUGF0aE9TLVwiK2tleV0pIHtcblx0XHRcdHJlc3VsdCA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlW1wiUGF0aE9TLVwiK2tleV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXHQvLyBTYXZlIHRoZSBvYmplY3Qgd2l0aCB0aGUga2V5XG5cdHNhdmU6IGZ1bmN0aW9uKGtleSwgb2JqKSB7XG5cdFx0bG9jYWxTdG9yYWdlW1wiUGF0aE9TLVwiK2tleV0gPSBKU09OLnN0cmluZ2lmeShvYmopO1xuXHR9LFxuXHQvLyBDbGVhciB0aGUga2V5J3MgZGF0YVxuXHRjbGVhcjogZnVuY3Rpb24oa2V5KSB7XG5cdFx0ZGVsZXRlIGxvY2FsU3RvcmFnZVtcIlBhdGhPUy1cIitrZXldO1xuXHR9LFxuXHRjbGVhbjogZnVuY3Rpb24oKSB7XG5cdFx0ZGVsZXRlIGxvY2FsU3RvcmFnZVsnUGF0aE9TLWhpc3RvcnknXTtcblx0XHRkZWxldGUgbG9jYWxTdG9yYWdlWydQYXRoT1MtbW9kdWxlcyddO1xuXHR9XG59O1xuXG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhZGRzIGEgbW9kdWxlIHRvIHRoZSBzaWRlYmFyLlxuICpcbiAqXG4gKlxuICogQHBhcmFtIGNvbmZpZ1xuICpcbiAqL1xuXG5QYXRoT1MubW9kdWxlID0gZnVuY3Rpb24oY29uZmlnKSB7XG5cblx0Ly9jb25zb2xlLmxvZyhcIkFkZGluZyBQYXRoT1MgbW9kdWxlLi4uIFwiK2NvbmZpZy5uYW1lKTtcblx0dmFyIHRoYXQgPSB0aGlzO1xuXHRQYXRoT1MubW9kdWxlcy5tYXBbY29uZmlnLm5hbWVdID0ge1xuXHRcdGRhdGE6IGNvbmZpZyxcblx0XHRvYmplY3Q6IHRoYXRcblx0fTtcblxuXHQvLyBHZXQgdGhlIGRpdiBvciBjcmVhdGUgb25lLlxuXHR2YXIgZGl2ID0gZDMuc2VsZWN0KCcjJytjb25maWcubmFtZSk7XG5cdGlmKGRpdi5lbXB0eSgpKSB7XG5cdFx0ZGl2ID0gdGhpcy5kaXYgPSBkMy5zZWxlY3QoXCIjc2lkZWJhclwiKVxuXHRcdFx0LmFwcGVuZChcImRpdlwiKVxuXHRcdFx0LmNsYXNzZWQoXCJtb2R1bGVcIiwgdHJ1ZSlcblx0XHRcdC5hdHRyKFwiaWRcIiwgY29uZmlnLm5hbWUpO1xuXHR9XG5cblx0Ly8gR2V0IHRoZSB0aXRsZSBvciBjcmVhdGUgb25lLlxuXHR2YXIgdGl0bGUgPSBkaXYuc2VsZWN0KFwiLm1vZHVsZXRpdGxlXCIpO1xuXHRpZih0aXRsZS5lbXB0eSgpKSB7XG5cdFx0dGl0bGUgPSBkaXYuYXBwZW5kKCd0YWJsZScpLmNsYXNzZWQoXCJtb2R1bGV0aXRsZVwiLCB0cnVlKS5hcHBlbmQoJ3RyJyk7XG5cblx0XHR0aXRsZS5hcHBlbmQoJ3RkJylcblx0XHRcdC5jbGFzc2VkKFwibW9kdWxlbGFiZWxcIiwgdHJ1ZSlcblx0XHRcdC5kYXR1bShjb25maWcpXG5cdFx0XHQub24oXCJjbGlja1wiLCB0aGF0LnRvZ2dsZSlcblx0XHQuYXBwZW5kKFwiYVwiKVxuXHRcdFx0LmF0dHIoJ2hyZWYnLCBcIiNcIiArIGNvbmZpZy5uYW1lKVxuXHRcdC5hcHBlbmQoXCJoMVwiKVxuXHRcdFx0LnRleHQoY29uZmlnLnRpdGxlKTtcblx0fSBlbHNlIHtcblx0XHR0aXRsZS5zZWxlY3QoJ3RkJykuY2xhc3NlZChcIm1vZHVsZWxhYmVsXCIsIHRydWUpLmRhdHVtKGNvbmZpZykub24oXCJjbGlja1wiLCB0aGF0LnRvZ2dsZSk7XG5cdH1cblxuXHR0aXRsZS5pbnNlcnQoJ3RkJywndGQnKVxuXHRcdC5kYXR1bShjb25maWcpXG5cdFx0Lm9uKFwiY2xpY2tcIiwgdGhhdC50b2dnbGUpXG5cdC5hcHBlbmQoXCJhXCIpXG5cdFx0LmF0dHIoJ2hyZWYnLCBcIiNcIitjb25maWcubmFtZSlcblx0LmFwcGVuZChcImlcIilcblx0XHQuY2xhc3NlZChcImZhIGZhLW1pbnVzLXNxdWFyZSBtaW5pbWlzZVwiLCB0cnVlKTtcblxuXHQvL2J1dHRvbnMgPSB0aXRsZS5hcHBlbmQoJ3RkJykuY2xhc3NlZCgnYnV0dG9ucycsIHRydWUpO1xuXG5cblx0Ly8gR2V0IHRoZSBjb250ZW50IG9yIGNyZWF0ZSBvbmUuXG5cblxuXHRmdW5jdGlvbiBidWlsZEhpc3RvcnlSb3coZCl7XG5cblx0XHR2YXIgdHlwZSA9ICcnO1xuXHRcdGlmKGQudGl0bGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdzZXFydW4nKSA+PSAwKSB7XG5cdFx0XHR0eXBlID0gJ1NlcXJ1bic7XG5cdFx0fSBlbHNlIGlmKGQudGl0bGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwdWJtZWQnKSA+PSAwKSB7XG5cdFx0XHR0eXBlID0gJ1B1Ym1lZCc7XG5cdFx0fSBlbHNlIGlmKGQudGl0bGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdzZXF1ZW5jZWQgdmFyaWFudHMgbGlzdCcpID49IDApIHtcblx0XHRcdHR5cGUgPSAnU2VxU2FtcGxlJztcblx0XHR9IGVsc2UgaWYoZC50aXRsZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ2N1cnZhcicpID49IDApIHtcblx0XHRcdHR5cGUgPSAnQ3VyVmFyaWFudCc7XG5cdFx0fSBlbHNlIGlmKGQudGl0bGUudG9Mb3dlckNhc2UoKS5pbmRleE9mKCdwYXRpZW50JykgPj0gMCkge1xuXHRcdFx0dHlwZSA9ICdQYXRTYW1wbGUnO1xuXHRcdH1cblxuICAgICAgICAvL1xuXHRcdC8vcm93LmFwcGVuZCgndGQnKS5hcHBlbmQoJ2knKS5jbGFzc2VkKCdkb2N1bWVudC1pY29uIGZhIGZhLXdwZm9ybXMnLCB0cnVlKVxuXHRcdC8vXHQuY2xhc3NlZCh0eXBlLCB0cnVlKTtcblxuXG5cdFx0dmFyIHJvdyA9IGJvZHkuYXBwZW5kKCd0cicpO1xuXHRcdHJvdy5hcHBlbmQoJ3RkJylcblx0XHRcdC5hcHBlbmQoJ2EnKVxuXHRcdFx0LmF0dHIoJ2hyZWYnLCBkLnVybCkudGV4dChkLnRpdGxlKS5jbGFzc2VkKHR5cGUsIHRydWUpO1xuXG5cdFx0cm93LmFwcGVuZCgndGQnKS50ZXh0KFBhdGhPUy50aW1lU2luY2UoZC50aW1lKSk7XG5cdH1cblxuXHRpZihjb25maWcudHlwZSkge1xuXHRcdHZhciBjb250ZW50ID0gZGl2LmFwcGVuZCgnZGl2JykuY2xhc3NlZCgnY29udGVudCcsIHRydWUpO1xuXHRcdHN3aXRjaCAoY29uZmlnLnR5cGUpIHtcblx0XHRcdGNhc2UgJ3RhZ3MnOlxuXG5cdFx0XHRcdHZhciBlZGl0ID0gdGl0bGUuYXBwZW5kKCd0ZCcpLmF0dHIoJ2lkJywgJ3RhZ3NfZWRpdF9idXR0b24nKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHQkKFwiI3RhZ3NcIikudG9nZ2xlQ2xhc3MoXCJlZGl0aW5nXCIpO1xuXG5cdFx0XHRcdFx0XHQkKCcjdGFnc19lZGl0X2J1dHRvbiBpJykudG9nZ2xlQ2xhc3MoJ2ZhLXBlbmNpbC1zcXVhcmUtbycpO1xuXHRcdFx0XHRcdFx0JCgnI3RhZ3NfZWRpdF9idXR0b24gaScpLnRvZ2dsZUNsYXNzKCdmYS1wZW5jaWwtc3F1YXJlJyk7XG5cblxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0LmFwcGVuZChcImFcIikuYXR0cignaHJlZicsIFwiI1wiK2NvbmZpZy5uYW1lKTtcblxuXHRcdFx0XHQvL2VkaXQuYXBwZW5kKCdwJykudGV4dChcIihFZGl0aW5nKVwiKTtcblx0XHRcdFx0ZWRpdC5hcHBlbmQoJ3NwYW4nKS5odG1sKFwiKEVkaXRpbmcpJm5ic3A7XCIpO1xuXHRcdFx0XHRlZGl0LmFwcGVuZChcImlcIikuY2xhc3NlZChcImJ1dHRvbiBmYSBmYS1wZW5jaWwtc3F1YXJlLW9cIiwgdHJ1ZSk7XG5cblx0XHRcdFx0dGl0bGUuYXBwZW5kKCd0ZCcpLmFwcGVuZChcImFcIikuYXR0cignaHJlZicsIFwiI1wiK2NvbmZpZy5uYW1lKVxuXHRcdFx0XHRcdC5hcHBlbmQoXCJpXCIpXG5cdFx0XHRcdFx0LmNsYXNzZWQoXCJmYSBmYS10aW1lc1wiLCB0cnVlKVxuXHRcdFx0XHRcdC5zdHlsZShcInBhZGRpbmctYm90dG9tXCIsICcxcHgnKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbihkKXtcblx0XHRcdFx0XHRcdGQzLnNlbGVjdChcIiNcIitjb25maWcubmFtZSkuc3R5bGUoJ2Rpc3BsYXknLCdub25lJyk7XG5cdFx0XHRcdFx0XHRjb25maWcuY2xvc2VNb2R1bGUoKTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRkMy5zZWxlY3QoXCIjdGFnc1wiKS5zdHlsZSgnZGlzcGxheScsJ25vbmUnKTtcblx0XHRcdFx0dmFyIHJvdyA9IGNvbnRlbnQuYXBwZW5kKCd0YWJsZScpXG5cdFx0XHRcdFx0LmFwcGVuZCgndGhlYWQnKVxuXHRcdFx0XHRcdC5hcHBlbmQoXCJ0clwiKS5jbGFzc2VkKCdyb3cnLHRydWUpO1xuXHRcdFx0XHRyb3cuYXBwZW5kKCd0aCcpLnRleHQoY29uZmlnLmRhdGEub2JqZWN0KTtcblx0XHRcdFx0cm93LmFwcGVuZCgndGgnKS50ZXh0KFwiXCIpLmF0dHIoXCJpZFwiLFwib2JqZWN0X2lkXCIpLnN0eWxlKCd0ZXh0LWFsaWduJywncmlnaHQnKTtcblxuXHRcdFx0XHR2YXIgYm94ID0gY29udGVudC5hcHBlbmQoJ2RpdicpLmNsYXNzZWQoJ2ZiLWJveCB0YWdzX2ZpZWxkJywgdHJ1ZSlcblx0XHRcdFx0XHQuYXR0cihcImlkXCIsICdtb2R1bGVUYWdCb3gnKVxuXHRcdFx0XHRcdC5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0JCgnI3RhZ190ZXh0X2FyZWEnKS5mb2N1cygpO1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbmZpZy5kYXRhLnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpe1xuXHRcdFx0XHRcdFBhdGhPUy50YWdzLmRyYXdUYWcoYm94LCB0YWcsIHRydWUpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0XHRib3guYXBwZW5kKCd0ZXh0YXJlYScpXG5cdFx0XHRcdFx0LmF0dHIoJ2lkJywgJ3RhZ190ZXh0X2FyZWEnKVxuXHRcdFx0XHRcdC5hdHRyKCdwbGFjZWhvbGRlcicsICdFbnRlciBUYWdzIEhlcmUnKTtcblxuXHRcdFx0XHQkKFwiI3RhZ190ZXh0X2FyZWFcIikuYXV0b2NvbXBsZXRlKHtcblx0XHRcdFx0ICAgIHNvdXJjZTogY29uZmlnLmRhdGEuYXZhaWxhYmxlVGFnc1xuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdCQoJ2JvZHknKS5vbihcImtleWRvd25cIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdFx0aWYgKGUgJiYgZS5rZXlDb2RlICYmIGUua2V5Q29kZSA9PSAxMyAmJiAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKFwiI3RhZ190ZXh0X2FyZWFcIikpe1xuXG5cdFx0XHRcdFx0XHR2YXIgdGFnID0gJCgnI3RhZ190ZXh0X2FyZWEnKS52YWwoKS50cmltKCk7XG5cdFx0XHRcdFx0XHQkKCcjdGFnX3RleHRfYXJlYScpLnZhbCgnJyk7XG5cblx0XHRcdFx0XHRcdC8vY29uc29sZS5sb2coXCJzdWJtaXR0aW5nIHRhZyEgXCIrdGFnKTtcblx0XHRcdFx0XHRcdGlmICh0YWcgJiYgdGFnICE9PSAnJyAmJiBQYXRoT1MudGFncy5jdXJyZW50X29iamVjdCkge1xuXHRcdFx0XHRcdFx0XHRQYXRoT1MudGFncy5hZGRUYWcoYm94LCB0YWcpO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fSBlbHNlIGlmIChlICYmIGUua2V5Q29kZSAmJiBlLmtleUNvZGUgPT0gOCAmJiAkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKFwiI3RhZ190ZXh0X2FyZWFcIikgJiYgJChcIiN0YWdfdGV4dF9hcmVhXCIpLnZhbCgpID09PSBcIlwiKXtcblx0XHRcdFx0XHRcdGlmKCQoXCIjbW9kdWxlVGFnQm94LnRhZ3NfZmllbGQgLnRhZ2RpdjpsYXN0XCIpLmxlbmd0aCAhPT0gMCl7XG5cdFx0XHRcdFx0XHRcdGlmICgkKFwiI21vZHVsZVRhZ0JveC50YWdzX2ZpZWxkIC50YWdkaXY6bGFzdFwiKS5oYXNDbGFzcygnZGVsZXRlRmxhZycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIGRhdGEgPSBkMy5zZWxlY3QoJChcIiNtb2R1bGVUYWdCb3gudGFnc19maWVsZCAudGFnZGl2Omxhc3RcIilbMF0pLmRhdHVtKCk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZihjb25maXJtKCdSZW1vdmUgdGFnIFwiJytkYXRhLmxhYmVsKydcIiBmcm9tIHRoaXMgb2JqZWN0PycpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBQYXRoT1MuY29udHJvbGxlcixcblx0XHRcdFx0XHRcdFx0XHRcdFx0b2JqaWQ6IFBhdGhPUy50YWdzLmN1cnJlbnRfb2JqZWN0LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0YWdpZDogZGF0YS5pZFxuXHRcdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiREVMRVRFXCIsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHVybDogXCIvUGF0aE9TL3RhZy9yZW1vdmVMaW5rP1wiICsgJC5wYXJhbShwYXJhbXMpLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocmVzdWx0ICE9ICdmYWlsJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0JCgnLnRhZy0nK2RhdGEuaWQpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYocmVsb2FkR3JpZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZWxvYWRHcmlkKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRjYWNoZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzc0RhdGE6IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0JChcIiNtb2R1bGVUYWdCb3gudGFnc19maWVsZCAudGFnZGl2Omxhc3RcIikudG9nZ2xlQ2xhc3MoXCJkZWxldGVGbGFnXCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRcdFx0XHR2YXIgZGF0YSA9IGQzLnNlbGVjdCgkKFwiI21vZHVsZVRhZ0JveC50YWdzX2ZpZWxkIC50YWdkaXY6bGFzdFwiKVswXSkuZGF0dW0oKTtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFBhdGhPUy5jb250cm9sbGVyLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRvYmppZDogUGF0aE9TLnRhZ3MuY3VycmVudF9vYmplY3QsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRhZ2lkOiBkYXRhLmlkXG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHRcdFx0JC5hamF4KHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJERUxFVEVcIixcblx0XHRcdFx0XHRcdFx0XHRcdFx0dXJsOiBcIi9QYXRoT1MvdGFnL3JlbW92ZUxpbms/XCIgKyAkLnBhcmFtKHBhcmFtcyksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihyZXN1bHQgIT0gJ2ZhaWwnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQkKCcudGFnLScrZGF0YS5pZCkucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZihyZWxvYWRHcmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlbG9hZEdyaWQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGNhY2hlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y29udGVudFR5cGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzRGF0YTogZmFsc2Vcblx0XHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaGlzdG9yeSc6XG5cdFx0XHRcdHZhciB0YWJsZSA9IGNvbnRlbnQuYXBwZW5kKCd0YWJsZScpLFxuXHRcdFx0XHRcdGhlYWQgPSB0YWJsZS5hcHBlbmQoJ3RoZWFkJykuYXBwZW5kKCd0cicpLFxuXHRcdFx0XHRcdGJvZHkgPSB0YWJsZS5hcHBlbmQoJ3Rib2R5Jyk7XG5cdFx0XHRcdGhlYWQuYXBwZW5kKCd0aCcpLnRleHQoJ1BhZ2UnKTtcblx0XHRcdFx0aGVhZC5hcHBlbmQoJ3RoJykudGV4dCgnVCcpO1xuXG5cdFx0XHRcdGNvbmZpZy5kYXRhLmZvckVhY2goYnVpbGRIaXN0b3J5Um93KTtcblxuXG5cdFx0XHRcdGJvZHkuYXBwZW5kKCdzcGFuJykuYXBwZW5kKCdhJykuYXR0cignaHJlZicsICcjJylcblx0XHRcdFx0XHQudGV4dChcIlNlZSBtb3JlXCIpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0UGF0aE9TLmhpc3RvcnkubW9yZSgpLmZvckVhY2goYnVpbGRIaXN0b3J5Um93KTtcblxuXHRcdFx0XHRcdCQodGhpcykucmVtb3ZlKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2VzdGFibGlzaGVkJzpcblx0XHRcdFx0Y29udGVudC5yZW1vdmUoKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHR2YXIgdWwgPSBjb250ZW50LmFwcGVuZChcInVsXCIpXG5cdFx0XHRcdFx0LnN0eWxlKCdjbGlwJywgXCJyZWN0KDBweCwgMTAwMHB4LCAwcHgsIDBweClcIik7XG5cblx0XHRcdFx0aWYoY29uZmlnLmRhdGEgaW5zdGFuY2VvZiBBcnJheSkge1xuXHRcdFx0XHRcdGNvbmZpZy5kYXRhLmZvckVhY2goZnVuY3Rpb24oZCl7XG5cdFx0XHRcdFx0XHR1bC5hcHBlbmQoXCJsaVwiKS5odG1sKGQpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdE9iamVjdC5rZXlzKGNvbmZpZy5kYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG5cdFx0XHRcdFx0XHR1bC5hcHBlbmQoXCJsaVwiKS5odG1sKGtleStcIjogXCIrY29uZmlnLmRhdGFba2V5XSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9XG5cblx0aWYoZGl2LmNsYXNzZWQoJ2hpZGUnKSB8fCBjb25maWcuaGlkZSkge1xuXHRcdGRpdi5jbGFzc2VkKCdoaWRlJywgZmFsc2UpO1xuXHRcdHRoYXQudG9nZ2xlKGNvbmZpZy5uYW1lKTtcblx0fVxuXG59O1xuXG5QYXRoT1MubW9kdWxlLnByb3RvdHlwZS50b2dnbGUgPSBmdW5jdGlvbihpdGVtKXtcblxuXHRpZihkMy5ldmVudCkge1xuXHRcdGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cblx0dmFyIG5hbWUgPSB0eXBlb2YgaXRlbSA9PSAnc3RyaW5nJyA/IGl0ZW0gOiBkMy5zZWxlY3QodGhpcykuZGF0dW0oKS5uYW1lO1xuXG5cdHZhciBpZCA9IFwiI1wiICsgbmFtZTtcblxuXHQkKGlkKS50b2dnbGVDbGFzcyhcImhpZGRlblwiKTtcblx0JChpZCtcIiBpLm1pbmltaXNlXCIpLnRvZ2dsZUNsYXNzKFwiZmEtbWludXMtc3F1YXJlXCIpO1xuXHQkKGlkK1wiIGkubWluaW1pc2VcIikudG9nZ2xlQ2xhc3MoXCJmYS1wbHVzLXNxdWFyZVwiKTtcblxuXHR2YXIgaGVpZ2h0ID0gJChpZCkuaGVpZ2h0KCk7XG5cblx0aWYoZDMuc2VsZWN0KGlkKS5jbGFzc2VkKFwiaGlkZGVuXCIpKSB7XG5cdFx0ZDMuc2VsZWN0KGlkKS5zdHlsZShcIm1pbi1oZWlnaHRcIiwgXCIxcHhcIik7XG5cblx0XHRpZihQYXRoT1MudXNlcikge1xuXHRcdFx0UGF0aE9TLm1vZHVsZXMuc2V0dGluZ3NbUGF0aE9TLnVzZXJdLmhpZGVbbmFtZV0gPSB0cnVlO1xuXHRcdFx0UGF0aE9TLmRhdGEuc2F2ZShcIm1vZHVsZXNcIiwgUGF0aE9TLm1vZHVsZXMuc2V0dGluZ3MpO1xuXHRcdH1cblx0fSBlbHNlIHtcblx0XHRkMy5zZWxlY3QoaWQpLnN0eWxlKFwibWluLWhlaWdodFwiLCBoZWlnaHQgKyBcInB4XCIpO1xuXG5cdFx0aWYoUGF0aE9TLnVzZXIpIHtcblx0XHRcdGRlbGV0ZSBQYXRoT1MubW9kdWxlcy5zZXR0aW5nc1tQYXRoT1MudXNlcl0uaGlkZVtuYW1lXTtcblx0XHRcdFBhdGhPUy5kYXRhLnNhdmUoXCJtb2R1bGVzXCIsIFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzKTtcblx0XHR9XG5cdH1cbn07XG5cblBhdGhPUy5tb2R1bGUucHJvdG90eXBlLmRhdGEgPSBmdW5jdGlvbigpe1xuXHR2YXIgZCA9IGQzLnNlbGVjdCh0aGlzKS5kYXR1bSgpO1xuXHRjb25zb2xlLmxvZyhkKTtcbn07XG5cbi8qKlxuICpcbiAqIEB0eXBlIHt7bWVudVZpc2libGU6IGJvb2xlYW4sIHNldHRpbmdzOiB7fSwgbWFwOiB7fSwgaW5pdDogUGF0aE9TLm1vZHVsZXMuaW5pdCwgbWVudToge3Nob3c6IFBhdGhPUy5tb2R1bGVzLm1lbnUuc2hvdywgaGlkZTogUGF0aE9TLm1vZHVsZXMubWVudS5oaWRlfX19XG4gKi9cblxuUGF0aE9TLm1vZHVsZXMgPSB7XG5cdG1lbnVWaXNpYmxlOiBmYWxzZSxcblx0c2V0dGluZ3M6IHt9LFxuXHRtYXA6IHt9LFxuXHRpbml0OiBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0XHQvL2dldCBzZXR0aW5ncyBpZiB0aGV5IGV4aXN0LCBvciB1c2UgZGVmYXVsdCBzZXR0aW5nc1xuXG5cdFx0Y29uc29sZS5sb2coXCJsb2FkaW5nIG1vZHVsZSBzZXR0aW5nc1wiKTtcblxuXHRcdC8vIExvYWQgc2V0dGluZ3Ncblx0XHRQYXRoT1MubW9kdWxlcy5zZXR0aW5ncyA9IFBhdGhPUy5kYXRhLmxvYWQoXCJtb2R1bGVzXCIpO1xuXG5cdFx0UGF0aE9TLmNvbnRyb2xsZXIgPSBvcHRpb25zLmNvbnRyb2xsZXI7XG5cdFx0UGF0aE9TLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuXG5cdFx0Ly8gSWYgdXNlcidzIHNldHRpbmdzIGV4aXN0Li4uXG5cdFx0aWYgKG9wdGlvbnMudXNlcikge1xuXHRcdFx0UGF0aE9TLnVzZXIgPSBvcHRpb25zLnVzZXI7XG5cdFx0XHRpZiAoUGF0aE9TLm1vZHVsZXMuc2V0dGluZ3NbUGF0aE9TLnVzZXJdKSB7XG5cdFx0XHRcdC8vc2V0IHRoaW5ncyBsaWtlIHJlb3JkZXJpbmcgdGFibGVzIGFuZCBoaXN0b3J5XG5cdFx0XHRcdE9iamVjdC5rZXlzKFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5oaWRlKS5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0aWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGQpICYmICFkMy5zZWxlY3QoXCIjXCIgKyBkKS5jbGFzc2VkKFwiaGlkZGVuXCIpKSB7XG5cblx0XHRcdFx0XHRcdGlmIChQYXRoT1MubW9kdWxlcy5tYXBbZF0pIHtcblx0XHRcdFx0XHRcdFx0UGF0aE9TLm1vZHVsZXMubWFwW2RdLm9iamVjdC50b2dnbGUoZCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIjXCIgKyBkKS5jbGFzc2VkKFwiaGlkZVwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cblxuXHRcdFx0XHRpZihQYXRoT1MubW9kdWxlcy5zZXR0aW5nc1tQYXRoT1MudXNlcl0uc2lkZWJhclt3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVdKSB7XG5cdFx0XHRcdFx0aWYgKFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5zaWRlYmFyW3dpbmRvdy5sb2NhdGlvbi5wYXRobmFtZV0gPT0gJ3Nob3cnKSB7XG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIjd3JhcHBlclwiKS5jbGFzc2VkKFwidG9nZ2xlZFwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIjc2lkZWJhci10b2dnbGUgaVwiKS5jbGFzc2VkKFwiZmEtY2hldnJvbi1sZWZ0XCIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGQzLnNlbGVjdChcIiNzaWRlYmFyLXRvZ2dsZSBpXCIpLmNsYXNzZWQoXCJmYS1jaGV2cm9uLXJpZ2h0XCIsIHRydWUpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoUGF0aE9TLm1vZHVsZXMuc2V0dGluZ3NbUGF0aE9TLnVzZXJdLnNpZGViYXJbd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lXSA9PSAnaGlkZScpIHtcblx0XHRcdFx0XHRcdGQzLnNlbGVjdChcIiN3cmFwcGVyXCIpLmNsYXNzZWQoXCJ0b2dnbGVkXCIsIHRydWUpO1xuXHRcdFx0XHRcdFx0ZDMuc2VsZWN0KFwiI3NpZGViYXItdG9nZ2xlIGlcIikuY2xhc3NlZChcImZhLWNoZXZyb24tbGVmdFwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdGQzLnNlbGVjdChcIiNzaWRlYmFyLXRvZ2dsZSBpXCIpLmNsYXNzZWQoXCJmYS1jaGV2cm9uLXJpZ2h0XCIsIGZhbHNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cblxuXG5cblxuXG5cblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aE9TLm1vZHVsZXMuc2V0dGluZ3NbUGF0aE9TLnVzZXJdID0ge1xuXHRcdFx0XHRcdHNpZGViYXI6IHt9LFxuXHRcdFx0XHRcdGhpZGU6IHt9LFxuXHRcdFx0XHRcdHN2bGlzdElHVjogXCJhc2tcIlxuXHRcdFx0XHR9O1xuXHRcdFx0XHRQYXRoT1MuZGF0YS5zYXZlKFwibW9kdWxlc1wiLCBQYXRoT1MubW9kdWxlcy5zZXR0aW5ncyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cblxuXHRcdGQzLnNlbGVjdChcIiNzaWRlYmFyLWZvb3RlclwiKVxuXHRcdC5hcHBlbmQoJ3NwYW4nKVxuXHRcdC5hcHBlbmQoJ2EnKVxuXHRcdFx0LmF0dHIoJ2hyZWYnLCAnIycpXG5cdFx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKXtcblx0XHRcdFx0aWYoUGF0aE9TLm1vZHVsZXMubWVudVZpc2libGUpIHtcblx0XHRcdFx0XHRQYXRoT1MubW9kdWxlcy5tZW51LmhpZGUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRQYXRoT1MubW9kdWxlcy5tZW51LnNob3coKTtcblx0XHRcdFx0fVxuXHRcdFx0fSkuYXBwZW5kKCdpJylcblx0XHRcdC5hdHRyKCdjbGFzcycsICdmYS1sZyBmYSBmYS1jb2cnKVxuXHRcdFx0LmF0dHIoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblx0fSxcblx0bWVudToge1xuXHRcdHNob3c6IGZ1bmN0aW9uKCl7XG5cdFx0XHRjb25zb2xlLmxvZyhcInNob3dpbmcgc2V0dGluZ3MhXCIpO1xuXG5cdFx0XHR2YXIgbWVudWJveCA9IGQzLnNlbGVjdCgnYm9keScpXG5cdFx0XHRcdC5hcHBlbmQoJ2RpdicpXG5cdFx0XHRcdC5hdHRyKCdpZCcsICdvdmVybGF5Jylcblx0XHRcdFx0Lm9uKCdjbGljaycsIFBhdGhPUy5tb2R1bGVzLm1lbnUuaGlkZSlcblx0XHRcdC5hcHBlbmQoJ2RpdicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgfSlcblx0XHRcdFx0LmF0dHIoJ2lkJywgJ21vZHVsZU1lbnUnKVxuXHRcdFx0XHQuY2xhc3NlZCgnZmItYm94JywgdHJ1ZSk7XG5cblx0XHRcdG1lbnVib3guYXBwZW5kKCdhJykuYXR0cignaHJlZicsICcjJykub24oJ2NsaWNrJywgUGF0aE9TLm1vZHVsZXMubWVudS5oaWRlKVxuXHRcdFx0XHQuYXBwZW5kKFwiaVwiKS5jbGFzc2VkKFwiZmEgZmEtY2xvc2UgZmEtbGdcIiwgdHJ1ZSk7XG5cblx0XHRcdG1lbnUgPSBtZW51Ym94LmFwcGVuZChcImRpdlwiKTtcblxuXHRcdFx0aGVhZGVyID0gbWVudS5hdHRyKCdpZCcsICdtbUhlYWRlcicpXG5cdFx0XHRcdC5hcHBlbmQoJ2gxJykudGV4dChcIlBhdGhPUyBPcHRpb25zXCIpO1xuXG5cblx0XHRcdGZ1bmN0aW9uIGRlc2VsZWN0SUdWKCl7XG5cdFx0XHRcdGQzLnNlbGVjdEFsbChcIiNJR1Ytb3B0aW9ucyBhXCIpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKFBhdGhPUy51c2VyKSB7XG5cdFx0XHRcdHZhciBpZ3YgPSBtZW51LmFwcGVuZChcInBcIilcblx0XHRcdFx0XHQuYXR0cignaWQnLCBcIklHVi1vcHRpb25zXCIpXG5cdFx0XHRcdFx0LnRleHQoXCJJR1YuanMgT3B0aW9uczogXCIpO1xuXG5cdFx0XHRcdGlndi5hcHBlbmQoXCJwXCIpLnRleHQoXCJJbi1icm93c2VyIElHViAoYWxzbyBrbm93biBhcyBJR1YuanMpIGNhbiBsb2FkIGluIHRoZSBiYWNrZ3JvdW5kIHdoaWxlIHlvdSBicm93c2UgUGF0aE9TLiBJdCBjYW4gYWxzbyBkb3duc2FtcGxlIHJlYWRzLCB3aGljaCB3aWxsIG1ha2UgbGFyZ2VyIHJ1bnMgZWFzaWVyIGZvciB5b3VyIGNvbXB1dGVyIHRvIGhhbmRsZS5cIik7XG5cblx0XHRcdFx0aWd2LmFwcGVuZChcImFcIilcblx0XHRcdFx0XHQuYXR0cignaHJlZicsXCIjXCIpXG5cdFx0XHRcdFx0LmF0dHIoJ2lkJywgXCJzdmxpc3QtaWd2LWF1dG9cIilcblx0XHRcdFx0XHQudGV4dChcIkF1dG8gTG9hZCAobm8gZG93bnNhbXBsaW5nKVwiKVxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRkZXNlbGVjdElHVigpO1xuXHRcdFx0XHRcdFx0ZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5zdmxpc3RJR1YgPSBcImF1dG9cIjtcblx0XHRcdFx0XHRcdFBhdGhPUy5kYXRhLnNhdmUoXCJtb2R1bGVzXCIsIFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0aWd2LmFwcGVuZChcImFcIilcblx0XHRcdFx0XHQuYXR0cignaHJlZicsIFwiI1wiKVxuXHRcdFx0XHRcdC5hdHRyKCdpZCcsXCJzdmxpc3QtaWd2LWRvd25zYW1wbGVcIilcblx0XHRcdFx0XHQudGV4dChcIkF1dG8gTG9hZCAoZG93bnNhbXBsZSB0byAyNTAwKVwiKVxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRkZXNlbGVjdElHVigpO1xuXHRcdFx0XHRcdFx0ZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5zdmxpc3RJR1YgPSBcImRvd25zYW1wbGVcIjtcblx0XHRcdFx0XHRcdFBhdGhPUy5kYXRhLnNhdmUoXCJtb2R1bGVzXCIsIFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzKTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0aWd2LmFwcGVuZChcImFcIilcblx0XHRcdFx0XHQuYXR0cignaHJlZicsXCIjXCIpXG5cdFx0XHRcdFx0LmF0dHIoJ2lkJywgXCJzdmxpc3QtaWd2LWFza1wiKVxuXHRcdFx0XHRcdC50ZXh0KFwiQXNrIEJlZm9yZSBMb2FkaW5nIElHVi5qc1wiKVxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0XHRkZXNlbGVjdElHVigpO1xuXHRcdFx0XHRcdFx0ZDMuc2VsZWN0KHRoaXMpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5zdmxpc3RJR1YgPSBcImFza1wiO1xuXHRcdFx0XHRcdFx0UGF0aE9TLmRhdGEuc2F2ZShcIm1vZHVsZXNcIiwgUGF0aE9TLm1vZHVsZXMuc2V0dGluZ3MpO1xuXHRcdFx0XHRcdH0pO1xuXG5cblx0XHRcdFx0aWYoUGF0aE9TLm1vZHVsZXMuc2V0dGluZ3NbUGF0aE9TLnVzZXJdKSB7XG5cdFx0XHRcdFx0dmFyIHN2bGlzdElHViA9IFBhdGhPUy5tb2R1bGVzLnNldHRpbmdzW1BhdGhPUy51c2VyXS5zdmxpc3RJR1Y7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBzdmxpc3RJR1YgID09ICd1bmRlZmluZWQnIHx8IHN2bGlzdElHViA9PSAnYXNrJykge1xuXHRcdFx0XHRcdFx0ZDMuc2VsZWN0KFwiI3N2bGlzdC1pZ3YtYXNrXCIpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN2bGlzdElHViA9PSAnZG93bnNhbXBsZScgKSB7XG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIjc3ZsaXN0LWlndi1kb3duc2FtcGxlXCIpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHN2bGlzdElHViA9PSAnYXV0bycgKSB7XG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QoXCIjc3ZsaXN0LWlndi1hdXRvXCIpLmNsYXNzZWQoXCJzZWxlY3RlZFwiLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXG5cdFx0XHRcdG1lbnUuYXBwZW5kKFwicFwiKVxuXHRcdFx0XHRcdC50ZXh0KFwiUGF0aE9TIEhpc3Rvcnk6IFwiKVxuXHRcdFx0XHQuYXBwZW5kKFwiYVwiKVxuXHRcdFx0XHRcdC50ZXh0KFwiQ2xlYXIgSGlzdG9yeVwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiaHJlZlwiLCBcIiNcIilcblx0XHRcdFx0XHQuYXR0cignaWQnLCAnY2xlYXJIaXN0b3J5Jylcblx0XHRcdFx0XHQub24oXCJjbGlja1wiLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdFx0UGF0aE9TLmRhdGEuY2xlYXIoXCJoaXN0b3J5XCIpO1xuXHRcdFx0XHRcdFx0YWxlcnQoXCJIaXN0b3J5IENsZWFyZWQhXCIpO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbGlua3MgPSBtZW51LmFwcGVuZCgncCcpLmF0dHIoJ2lkJywncGF0aG9zLW1lbnUtbGlua3MnKS50ZXh0KFwiTGlua3MgdG86IFwiKTtcblxuXHRcdFx0bGlua3MuYXBwZW5kKFwiYVwiKVxuXHRcdFx0XHQuYXR0cignaHJlZicsIFwiaHR0cHM6Ly8xMTUuMTQ2Ljg2LjExOC9qaXJhL3NlY3VyZS9EYXNoYm9hcmQuanNwYVwiKVxuXHRcdFx0XHQudGV4dChcIkppcmFcIik7XG5cdFx0XHRsaW5rcy5hcHBlbmQoXCJzcGFuXCIpLnRleHQoXCIgLSBcIik7XG5cdFx0XHRsaW5rcy5hcHBlbmQoJ2EnKS5hdHRyKCdocmVmJywgJ2h0dHBzOi8vMTE1LjE0Ni44Ni4xMTgvY29uZmx1ZW5jZS9kaXNwbGF5L1BWUy9QYXRoT1MrVmFyaWFudCtTeXN0ZW0nKS50ZXh0KFwiQ29uZmx1ZW5jZVwiKTtcblx0XHRcdGxpbmtzLmFwcGVuZChcInNwYW5cIikudGV4dChcIiAtIFwiKTtcblx0XHRcdGxpbmtzLmFwcGVuZCgnYScpLmF0dHIoJ2hyZWYnLCAnaHR0cDovL3BhdGhvcy5jby9oZWxwJykudGV4dChcIkhlbHBcIik7XG5cblxuXHRcdFx0Ly9UdXJuIG9mZiBob3RrZXlzLCBhbmQgbWFrZSBcImVzY1wiIGhpZGUgdGhlIG1lbnVcblx0XHRcdFBhdGhPUy5ob3RrZXlzLm9mZigpO1xuXHRcdFx0JCgnYm9keScpLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdGlmKGUgJiYgZS5rZXlDb2RlICYmIGUua2V5Q29kZSA9PSAyNyAmJiAhJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyhcImlucHV0XCIpICYmICEkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKFwidGV4dGFyZWFcIikgJiYgIWUuYWx0S2V5ICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSl7XG5cdFx0XHRcdFx0UGF0aE9TLm1vZHVsZXMubWVudS5oaWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0sXG5cdFx0aGlkZTogZnVuY3Rpb24oKXtcblx0XHRcdGNvbnNvbGUubG9nKFwiaGlkaW5nIHNldHRpbmdzIVwiKTtcblxuXHRcdFx0Ly8gR2V0IHJpZCBvZiB0aGUgbWVudVxuXHRcdFx0ZDMuc2VsZWN0KFwiI292ZXJsYXlcIikucmVtb3ZlKCk7XG5cdFx0XHQvLyBCcmluZyBiYWNrIHRoZSBob3RrZXlzLi4uXG5cdFx0XHRQYXRoT1MuaG90a2V5cy5pbml0KCk7XG5cblx0XHR9XG5cdH1cbn07XG5cblxuLyoqXG4gKiBUaGlzIGJ1bmRsZSBpcyBmb3IgdGhlIHN2bGlzdCBwYWdlIGFuZCBzaG93aW5nIEN1cmF0ZWQgVmFyaWFudHNcbiAqXG4gKiBES0dNIDIxLU9jdG9iZXItMjAxNlxuICpcbiAqIEB0eXBlIHt7c2hvd0NWOiBQYXRoT1Muc3ZsaXN0LnNob3dDViwgY2xvc2VDVjogUGF0aE9TLnN2bGlzdC5jbG9zZUNWfX1cbiAqL1xuXG5QYXRoT1Muc3ZsaXN0ID0ge1xuXHRldmlkZW5jZToge1xuXHRcdCdwYXRoQWxvbmVUcnVuY2F0aW5nJzpcIlRydW5jYXRpbmcgdmFyaWFudCAobm9uc2Vuc2UsIGZyYW1lc2hpZnQsIGNhbm9uaWNhbCBzcGxpY2Ugc2l0ZSwgaW5pdGlhdGlvbiBjb2RvbikgaW4gYSBrbm93biB0dW1vdXIgc3VwcHJlc3NvciBnZW5lXCIsXG5cdFx0J3BhdGhBbG9uZUtub3duJzpcIlNhbWUgbWlzc2Vuc2UgY2hhbmdlIGFzIGEgcHJldmlvdXNseSBlc3RhYmxpc2hlZCBwYXRob2dlbmljIHZhcmlhbnRcIixcblx0XHQncGF0aFN0cm9uZ0Z1bmN0aW9uJzpcIldlbGwtZXN0YWJsaXNoZWQgaW4gdml0cm8gb3IgaW4gdml2byBmdW5jdGlvbmFsIHN0dWRpZXMgc3VwcG9ydCBhIGRlbGV0ZXJpb3VzIGVmZmVjdCBvbiB0aGUgZ2VuZSBvciBnZW5lIHByb2R1Y3RcIixcblx0XHQncGF0aFN0cm9uZ0Nhc2UnOlwiQ2FzZS1jb250cm9sIHN0dWRpZXMgc2hvdyBlbnJpY2htZW50IGluIGNhc2VzXCIsXG5cdFx0J3BhdGhTdHJvbmdDb3NlZyc6XCI8Yj48aT5Gb3IgZmFtaWxpYWwgY2FuY2VyIG9ubHk6PC9pPjwvYj4gUHJvYmFuZCdzIGZhbWlseSBzdHVkeSBzaG93cyBjby1zZWdyZWdhdGlvbiB3aXRoIGNhbmNlclwiLFxuXHRcdCdwYXRoU3VwcG9ydEhvdHNwb3QnOlwiTG9jYXRlZCBuZWFyIGEga25vd24gbXV0YXRpb25hbCBob3Qtc3BvdCBvciB3aXRoaW4gYSB3ZWxsLWNoYXJhY3RlcmlzZWQgZnVuY3Rpb25hbCBkb21haW5cIixcblx0XHQncGF0aFN1cHBvcnRHZW5lJzpcIk9jY3VycyBpbiBhIGdlbmUgd2l0aCBoaWdoIGNsaW5pY2FsIHNwZWNpZmljaXR5IGFuZCBzZW5zaXRpdml0eSBmb3IgdGhlIGNhbmNlclwiLFxuXHRcdCdwYXRoU3VwcG9ydEluc2lsaWNvJzpcIk11bHRpcGxlIHR5cGVzIG9mIGNvbXB1dGF0aW9uYWwgZXZpZGVuY2Ugc3VwcG9ydCBhIGRlbGV0ZXJpb3VzIGVmZmVjdCBvbiB0aGUgZ2VuZSBvciBnZW5lIHByb2R1Y3QgKFBvbHlQaGVuLCBTSUZULCBNdXRhdGlvbiBUYXN0ZXIgLGNvbnNlcnZhdGlvbiwgZXZvbHV0aW9uLCBzcGxpY2luZylcIixcblx0XHQncGF0aFN1cHBvcnRTcGVjdHJ1bSc6XCJUeXBlIG9mIHZhcmlhbnQgZml0cyBrbm93biBtdXRhdGlvbiBzcGVjdHJ1bSBmb3IgdGhlIGdlbmVcIixcblx0XHQncGF0aFN1cHBvcnRHbWFmJzpcIkFic2VudCBmcm9tIEVTUCBhbmQgMTAwMCBHZW5vbWVzIGRhdGEsIG9yIGZyZXF1ZW5jeSBpcyBiZWxvdyBoaWdoZXN0IGdsb2JhbCBtaW5vciBhbGxlbGUgZnJlcXVlbmN5IChHTUFGKSBleHBlY3RlZCBmb3IgYXV0b3NvbWFsIGRvbWluYW50IGRpc2Vhc2UgKDAuNCUpXCIsXG5cdFx0J3BhdGhTdXBwb3J0SW5kZWwnOlwiSW4tZnJhbWUgZGVsZXRpb24vaW5zZXJ0aW9uIGluIGEgd2VsbCBjaGFyYWN0ZXJpc2VkIGZ1bmN0aW9uYWwgZG9tYWluXCIsXG5cdFx0J3BhdGhTdXBwb3J0Tm92ZWxNaXNzZW5zZSc6XCJOb3ZlbCBtaXNzZW5zZSBjaGFuZ2UgYXQgYW4gYW1pbm8gYWNpZCB3aGVyZSBhIGRpZmZlcmVudCBtaXNzZW5zZSBjaGFuZ2UgaXMgcGF0aG9nZW5pY1wiLFxuXHRcdCdwYXRoU3VwcG9ydExzZGInOlwiTm90ZWQgYXMgcGF0aG9nZW5pYyBpbiBhIGN1cmF0ZWQgbG9jdXMgc3BlY2lmaWMgZGF0YWJhc2VcIixcblx0XHQncGF0aFN1cHBvcnRDb3NlZyc6XCI8Yj48aT5Gb3IgZmFtaWxpYWwgY2FuY2VyIG9ubHk6PC9pPjwvYj4gUHJvYmFuZCdzIGZhbWlseSBzdHVkeSBzaG93cyBjby1zZWdyZWdhdGlvbiB3aXRoIGRpc2Vhc2VcIixcblx0XHQnYmVuaWduQWxvbmVHbWFmJzpcIkV4aXN0cyBpbiBFU1AgYW5kIDEwMDAgR2Vub21lcyA+PSAwLjQlIEdNQUZcIixcblx0XHQnYmVuaWduQWxvbmVIZWFsdGh5JzpcIjxiPjxpPkZvciBmYW1pbGlhbCBjYW5jZXIgb25seTo8L2k+PC9iPiBGb3IgYSBmdWxseSBwZW5ldHJhbnQgY2FuY2VyIHN5bmRyb21lLCBvYnNlcnZlZCBpbiBhIGhlYWx0aHkgYWR1bHQgaW5kaXZpZHVhbFwiLFxuXHRcdCdiZW5pZ25TdHJvbmdGdW5jdGlvbic6XCJXZWxsLWVzdGFibGlzaGVkIGluIHZpdHJvIG9yIGluIHZpdm8gZnVuY3Rpb25hbCBzdHVkaWVzIHNob3dzIG5vIGRlbGV0ZXJpb3VzIGVmZmVjdCBvbiBwcm90ZWluIGZ1bmN0aW9uIG9yIHNwbGljaW5nXCIsXG5cdFx0J2JlbmlnblN0cm9uZ0Nhc2UnOlwiQ2FzZSBjb250cm9sIHN0dWRpZXMgc2hvdyBjb21wYXJhYmxlIGZyZXF1ZW5jaWVzXCIsXG5cdFx0J2JlbmlnblN0cm9uZ0Nvc2VnJzpcIjxiPjxpPkZvciBmYW1pbGlhbCBjYW5jZXIgb25seTo8L2k+PC9iPiBWYXJpYW50IGZhaWxzIHRvIGNvLXNlZ3JlZ2F0ZSB3aXRoIGRpc2Vhc2UgaW4gYSBmYW1pbHkgc3R1ZHlcIixcblx0XHQnYmVuaWduU3VwcG9ydFZhcmlhYmxlJzpcIkxvY2F0ZWQgaW4gYSByZWdpb24gd2l0aG91dCBhIGNoYXJhY3RlcmlzZWQgZnVuY3Rpb24gb3IgYXdheSBmcm9tIGtub3duIG11dGF0aW9uIGhvdC1zcG90c1wiLFxuXHRcdCdiZW5pZ25TdXBwb3J0SW5zaWxpY28nOlwiTXVsdGlwbGUgdHlwZXMgb2YgY29tcHV0YXRpb25hbCBldmlkZW5jZSBzdWdnZXN0IG5vIGltcGFjdCBvbiBnZW5lIG9yIGdlbmUgcHJvZHVjdCAoUG9seVBoZW4sIFNJRlQsIE11dGF0aW9uIFRhc3RlciwgY29uc2VydmF0aW9uLCBldm9sdXRpb24sIHNwbGljaW5nKVwiLFxuXHRcdCdiZW5pZ25TdXBwb3J0U3BlY3RydW0nOlwiVHlwZSBvZiB2YXJpYW50IGRvZXMgbm90IGZpdCBrbm93biBtdXRhdGlvbiBzcGVjdHJ1bSBmb3IgdGhlIGdlbmVcIixcblx0XHQnYmVuaWduU3VwcG9ydExzZGInOlwiTm90ZWQgYXMgYmVuaWduIGluIGEgY3VyYXRlZCBsb2N1cyBzcGVjaWZpYyBkYXRhYmFzZVwiLFxuXHRcdCdiZW5pZ25TdXBwb3J0UGF0aCc6XCI8Yj48aT5Gb3IgZmFtaWxpYWwgY2FuY2VyIG9ubHk6PC9pPjwvYj4gRm9yIGEgZnVsbHkgcGVuZXRyYW50IGNhbmNlciBzeW5kcm9tZSwgb2JzZXJ2ZWQgd2l0aCBhbm90aGVyIHBhdGhvZ2VuaWMgdmFyaWFudCBpbiB0aGUgc2FtZSBpbmRpdmlkdWFsXCJcblx0fSxcblx0Ly8gQ2xpbiBDb250ZXh0IENvbXBhcml0b3Jcblx0Ly8gREtHTSAxOC1Ob3YtMjAxNlxuXHQvLyBSZXdyaXRlIHRoaXMgYmV0dGVyLiBUaGlzIGlzIGp1c3QgaGFja2VkIGZvciBhIGRlbW8uXG5cdGNjYzogZnVuY3Rpb24oYSwgYikge1xuXHRcdHZhciByZXN1bHQgPSBmYWxzZTtcblx0XHRpZiAoYSA9PT0gbnVsbCB8fCBiID09PSBudWxsKSB7XG5cdFx0XHRpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG5cdFx0XHRcdHJlc3VsdCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChhLmlkID09IGIuaWQpIHtcblx0XHRcdFx0cmVzdWx0ID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fSxcblx0Y3JlYXRlQ1Y6IGZ1bmN0aW9uICggc3YgKSB7XG5cdFx0Y29uc29sZS5sb2coXCJPaywgSSBndWVzcyB3ZSdyZSBtYWtpbmcgYSBDViBub3cuLi5cIik7XG5cdFx0Y29uc29sZS5sb2coXCJZb3VyIHN2IGlzOiBcIitzdik7XG5cdFx0Y29uc29sZS5sb2codGhpcyk7XG5cblx0XHR2YXIgY2MgPSAkKFwiI25ld0NWY2NcIikudmFsKCk7XG5cblx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0aWQ6IHN2LFxuXHRcdFx0Y2M6IGNjXG5cdFx0fTtcblx0XHQkLmFqYXgoe1xuXHRcdFx0dHlwZTogXCJQT1NUXCIsXG5cdFx0XHR1cmw6IFwiL1BhdGhPUy9DdXJWYXJpYW50L25ld0NWP1wiICsgJC5wYXJhbShwYXJhbXMpLFxuXHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKGQpIHtcblx0XHRcdFx0aWYgKHR5cGVvZiBkID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRhbGVydChkKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLmxvZyhkKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGNhY2hlOiBmYWxzZSxcblx0XHRcdGNvbnRlbnRUeXBlOiBmYWxzZSxcblx0XHRcdHByb2Nlc3NEYXRhOiBmYWxzZVxuXHRcdH0pO1xuXHR9LFxuXHRzYXZlQ1Y6IGZ1bmN0aW9uICggY3YgKSB7XG5cdFx0dmFyIHJlcG9ydCA9ICdmYWlsJztcblx0XHR2YXIgZXZpZGVuY2UgPSAnbG9sJztcblxuXHRcdHJlcG9ydCA9ICQoXCIjY3YtXCIrY3YrXCIgLnJlcG9ydFwiKS52YWwoKTtcblx0XHRldmlkZW5jZSA9ICQoXCIjY3YtXCIrY3YrXCIgLmV2aWRlbmNlXCIpLnZhbCgpO1xuXG5cblx0XHR2YXIgcGFyYW1zID0ge1xuXHRcdFx0aWQ6IGN2LFxuXHRcdFx0cmVwb3J0OiByZXBvcnQsXG5cdFx0XHRldmlkZW5jZTogZXZpZGVuY2Vcblx0XHR9O1xuXHRcdCQuYWpheCh7XG5cdFx0XHR0eXBlOiBcIlBPU1RcIixcblx0XHRcdHVybDogXCIvUGF0aE9TL0N1clZhcmlhbnQvdXBkYXRlQ1Y/XCIgKyAkLnBhcmFtKHBhcmFtcyksXG5cdFx0XHRzdWNjZXNzOiBmdW5jdGlvbiAoZCkge1xuXHRcdFx0XHRpZiAodHlwZW9mIGQgPT0gXCJzdHJpbmdcIikge1xuXHRcdFx0XHRcdGFsZXJ0KGQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGQpO1xuXHRcdFx0XHRcdC8vaWYgKGRpdi5zZWxlY3QoXCIudGFnLVwiKyBkLmlkKS5lbXB0eSgpKSB7XG5cdFx0XHRcdFx0Ly9cdFBhdGhPUy50YWdzLmRyYXdUYWcoZGl2LCBkLCB0cnVlKTtcblx0XHRcdFx0XHQvL1x0JCgnI3RhZ190ZXh0X2FyZWEnKS52YWwoJycpO1xuXHRcdFx0XHRcdC8vfVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2FjaGU6IGZhbHNlLFxuXHRcdFx0Y29udGVudFR5cGU6IGZhbHNlLFxuXHRcdFx0cHJvY2Vzc0RhdGE6IGZhbHNlXG5cdFx0fSk7XG5cblx0XHRjb25zb2xlLmxvZyhcIlRyeWluZyB0byBzYXZlOiBcIitjdik7XG5cdFx0Y29uc29sZS5sb2coXCJyZXBvcnQgaXM6IFwiK3JlcG9ydCk7XG5cdFx0Y29uc29sZS5sb2coXCJldmlkZW5jZSBpczogXCIrZXZpZGVuY2UpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBES0dNIDIxLU5vdmVtYmVyLTIwMTZcblx0ICpcblx0ICogQ2FsbCB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIHN2bGlzdCBwYWdlIHRvIGJ1aWxkIGFuIG92ZXJsYXkuXG5cdCAqIFRoZSBvdmVybGF5IHdpbGwgc2hvdyBhbGwgQ3VyYXRlZCBWYXJpYW50cyBmb3IgYSBzcGVjaWZpZWQgU2VxdWVuY2VkIFZhcmlhbnQuXG5cdCAqXG5cdCAqIEJ1aWxkIHRoZSBvdmVybGF5LCB0aGVuIGRvIGFuIGFqYXggY2FsbCBmb3IgdGhlIGluZm9ybWF0aW9uLlxuXHQgKiBLZXkgaW5mbzpcblx0ICogLSBTZXFWYXJpYW50IGluZm9cblx0ICogLSBMaXN0IG9mIEN1cmF0ZWQgVmFyaWFudHNcblx0ICpcblx0ICogQHBhcmFtIHN2XG4gICAgICovXG5cblx0c2hvd0NWczogZnVuY3Rpb24oIHN2ICkge1xuXHRcdGNvbnNvbGUubG9nKFwiU2hvd2luZyBhbGwgQ3VyYXRlZCBWYXJpYW50cyBmb3IgdGhpcyBTZXF1ZW5jZWQgVmFyaWFudFwiKTtcblxuXG4vLyBCdWlsZCB0aGUgT3ZlcmxheVxuXHRcdHZhciBjdmJveCA9IGQzLnNlbGVjdCgnYm9keScpXG5cdFx0XHQuYXBwZW5kKCdkaXYnKVxuXHRcdFx0LmF0dHIoJ2lkJywgJ292ZXJsYXknKVxuXHRcdFx0Lm9uKCdjbGljaycsIFBhdGhPUy5zdmxpc3QuY2xvc2VDVilcblx0XHRcdC5hcHBlbmQoJ2RpdicpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkgeyBkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgfSlcblx0XHRcdC5hdHRyKCdpZCcsICdzaG93LWN2Jylcblx0XHRcdC5jbGFzc2VkKCdmYi1ib3gnLCB0cnVlKVxuXHRcdFx0LmNsYXNzZWQoXCJjb250YWluZXJcIiwgdHJ1ZSk7XG5cblx0XHRjdmJveC5hcHBlbmQoJ2EnKS5hdHRyKCdocmVmJywgJyMnKS5vbignY2xpY2snLCBQYXRoT1Muc3ZsaXN0LmNsb3NlQ1YpXG5cdFx0XHQuYXBwZW5kKFwiaVwiKS5jbGFzc2VkKFwiZmEgZmEtY2xvc2UgZmEtbGdcIiwgdHJ1ZSk7XG5cblx0XHR2YXIgY3ZkaXYgPSBjdmJveC5hcHBlbmQoXCJkaXZcIik7XG5cblx0XHRjdmRpdi5hcHBlbmQoXCJpbWdcIilcblx0XHRcdC5jbGFzc2VkKFwibG9hZGluZ19sb2dvXCIsIHRydWUpXG5cdFx0XHQuYXR0cihcImlkXCIsIFwiY3YtbG9hZGluZ1wiKVxuXHRcdFx0LmF0dHIoXCJzcmNcIiwgXCIvUGF0aE9TL2Rpc3QvaW1nL3BhdGhvc19sb2dvX2FuaW1hdGVkLnN2Z1wiKTtcblxuXHRcdCQuYWpheChcIi9QYXRoT1MvU2VxVmFyaWFudC9sb29rVXBDVnM/aWQ9XCIrc3YsIHtzdWNjZXNzOmZ1bmN0aW9uKGQpe1xuXHRcdFx0ZDMuc2VsZWN0KFwiI2N2LWxvYWRpbmdcIikucmVtb3ZlKCk7XG5cdFx0XHRjb25zb2xlLmxvZyhkKTtcblxuXHRcdFx0dmFyIGhlYWRlciA9IGN2ZGl2LmF0dHIoJ2lkJywgJ2N2SGVhZGVyJylcblx0XHRcdFx0LmFwcGVuZCgnaDEnKS50ZXh0KFwiU2VxdWVuY2VkIFZhcmlhbnQ6IFwiKyBkLnN2LmhndnNjKTtcblxuXHRcdFx0Y29uc29sZS5sb2coIFwiU1YgaWQgaXM6IFwiICsgc3YgKTtcblxuXHRcdFx0dmFyIGluZm9ib3ggPSBjdmRpdi5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0LmF0dHIoXCJpZFwiLCBcInN2LWluZm9cIilcblx0XHRcdFx0LmNsYXNzZWQoXCJyb3dcIiwgdHJ1ZSk7XG5cblx0XHRcdC8vaW5mb2JveC5hcHBlbmQoXCJkaXZcIilcblx0XHRcdC8vXHQuY2xhc3NlZChcImZiLWJveFwiLCB0cnVlKVxuXHRcdFx0Ly9cdC5hcHBlbmQoXCJoMlwiKVxuXHRcdFx0Ly9cdC50ZXh0KFwiSW5mbyB0byBnbyBpbiBoZXJlXCIpO1xuLy8gQWRkIGluZm8gYWJvdXQgdGhlIHNlcXZhcmlhbnRcbi8vXG5cdFx0XHR2YXIgc2VxVmFyQm94ID0gaW5mb2JveC5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0LmNsYXNzZWQoXCJmYi1ib3hcIiwgdHJ1ZSlcblx0XHRcdFx0LmNsYXNzZWQoXCJjb2wteHMtNSBjb2wteHMtb2Zmc2V0LTFcIiwgdHJ1ZSlcblx0XHRcdFx0LmF0dHIoXCJpZFwiLCBcInN2LWluZm9ib3gtZGl2XCIpO1xuXG5cdFx0XHRzZXFWYXJCb3guYXBwZW5kKFwiaDJcIikudGV4dChcIlNlcXVlbmNlZCBWYXJpYW50IGluZm9ybWF0aW9uOlwiKTtcblxuXHRcdFx0c3ZDbGluQ29udGV4dCA9IFwiTm9uZVwiO1xuXHRcdFx0aWYgKGQuc3YuY2xpbkNvbnRleHQpIHtcblx0XHRcdFx0c3ZDbGluQ29udGV4dCA9IGQubG9va3VwLmNvbnRleHQoZC5zdi5jb250ZXh0LmlkKTtcblx0XHRcdH1cblx0XHRcdHZhciBib3gxID0ge1xuXHRcdFx0XHRcIkdlbmVcIjogZC5zdi5nZW5lLFxuXHRcdFx0XHRcIkhHVlNDXCI6IGQuc3YuaGd2c2MsXG5cdFx0XHRcdFwiSEdWU0dcIjogZC5zdi5oZ3ZzZyxcblx0XHRcdFx0XCJIR1ZTUFwiOiBkLnN2LmhndnNwLFxuXHRcdFx0XHRcIkNsaW5pY2FsIENvbnRleHQgKGZyb20gc2FtcGxlKVwiOiBzdkNsaW5Db250ZXh0LFxuXHRcdFx0XHRcIkNvbnNlcXVlbmNlc1wiOiBkLnN2LmNvbnNlcXVlbmNlLFxuXHRcdFx0XHRcIlZhcmlhbnQgQ2FsbGVyXCI6IGQuc3YudmFyY2FsbGVyLFxuXHRcdFx0XHRcIkFtcGxpY29uIENvdW50XCI6IGQuc3YubnVtYW1wcyxcblx0XHRcdFx0XCJBbXBsaWNvbiBCaWFzXCI6IGQuc3YuYW1wYmlhc1xuXHRcdFx0fTtcblx0XHRcdHZhciBib3gyID0ge1xuXHRcdFx0XHRcIlZhcmlhbnQgRnJlcXVlbmN5XCI6IGQuc3YudmFyRnJlcSxcblx0XHRcdFx0XCJWYXJpYW50IERlcHRoXCI6IGQuc3YudmFyRGVwdGgsXG5cdFx0XHRcdFwiUGFuZWwgVmFyICVcIjogZDMuZm9ybWF0KFwiLjRcIikoZC5zdi52YXJQYW5lbFBjdCkrXCIlXCIsXG5cdFx0XHRcdFwiZGJTTlBcIjogZC5zdi5kYnNucCxcblx0XHRcdFx0XCJHTUFGICVcIjogZC5zdi5nbWFmLFxuXHRcdFx0XHRcIkVTUCAlXCI6IGQuc3YuZXNwLFxuXHRcdFx0XHRcIkV4QUMgJVwiOiBkLnN2LmV4YWMsXG5cdFx0XHRcdFwiQ29zbWljXCI6IGQuc3YuY29zbWljID8gXCI8YSB0YXJnZXQ9J19ibGFuaycgaHJlZj0nL1BhdGhPUy9zZXFWYXJpYW50L2Nvc21pY0FjdGlvbj9pZD0nXCIrIGQuc3YuaWQrXCIgdGl0bGU9J1wiKyBkLnN2LmNvc21pY09jY3VycytcIic+Q09TTVwiKyBkLnN2LmNvc21pYytcIjwvYT5cIiA6IFwiXCIsXG5cdFx0XHRcdFwiRXhvblwiOiBkLnN2LmV4b24sXG5cdFx0XHRcdFwiQ3l0b2JhbmRcIjogZC5zdi5jeXRvYmFuZCxcblx0XHRcdFx0XCJDQUREIFJhd1wiOiBkMy5mb3JtYXQoXCIoLjJmXCIpKGQuc3YuY2FkZCksXG5cdFx0XHRcdFwiQ0FERCBTY2FsZWRcIjogZDMuZm9ybWF0KFwiKC4yZlwiKShkLnN2LmNhZGRfcGhyZWQpXG5cdFx0XHR9O1xuXG5cdFx0XHRkcmF3VGFibGUoYm94MSwgc2VxVmFyQm94KTtcblxuXHRcdFx0dmFyIG90aGVyQm94ID0gaW5mb2JveC5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0LmNsYXNzZWQoXCJmYi1ib3hcIiwgdHJ1ZSlcblx0XHRcdFx0LmNsYXNzZWQoXCJjb2wteHMtNVwiLCB0cnVlKVxuXHRcdFx0XHQuYXR0cihcImlkXCIsIFwiY3YtaW5mb2JveC1kaXZcIik7XG5cblx0XHRcdGRyYXdUYWJsZShib3gyLCBvdGhlckJveCk7XG5cbi8vIEFkZCBpbmZvIGFib3V0IHRoZSBQcmVmZXJyZWQgQ3VyYXRlZCBWYXJpYW50XG4vL1x0XHRcdHZhciBwcmVmZXJyZWRDVmJveCA9IGluZm9ib3guYXBwZW5kKFwiZGl2XCIpXG4vL1x0XHRcdFx0LmNsYXNzZWQoXCJmYi1ib3hcIiwgdHJ1ZSlcbi8vXHRcdFx0XHQuY2xhc3NlZChcImNvbC14cy0zXCIsIHRydWUpXG4vL1x0XHRcdFx0LmF0dHIoXCJpZFwiLCBcImN2LWluZm9ib3gtZGl2XCIpO1xuLy9cdFx0XHRwcmVmZXJyZWRDVmJveC5hcHBlbmQoXCJoMlwiKS50ZXh0KFwiQ3VyYXRlZCBWYXJpYW50IEluZm9ybWF0aW9uOlwiKTtcbi8vXG4vL1x0XHRcdHN2Q2xpbkNvbnRleHQgPSBcIk5vbmVcIjtcbi8vXHRcdFx0aWYgKGQuc3YuY2xpbkNvbnRleHQpIHtcbi8vXHRcdFx0XHRzdkNsaW5Db250ZXh0ID0gZC5sb29rdXAuY29udGV4dChkLnN2LmNvbnRleHQuaWQpO1xuLy9cdFx0XHR9XG4vL1xuLy9cdFx0XHR2YXIgdGVtcFBtQ2xhc3MgPSBudWxsO1xuLy9cdFx0XHRpZiAoZC5wcmVmZXJyZWQgJiYgZC5wcmVmZXJyZWQucG1DbGFzcykge1xuLy9cdFx0XHRcdHRlbXBQbUNsYXNzID0gZC5wcmVmZXJyZWQucG1DbGFzcztcbi8vXHRcdFx0fVxuLy9cbi8vXHRcdFx0dmFyIHByZWZlcnJlZERhdGEgPSB7XG4vL1x0XHRcdFx0XCJDbGFzc2lmaWNhdGlvblwiOiB0ZW1wUG1DbGFzcyxcbi8vXHRcdFx0XHRcIkNsYXNzaWZpZWQgQnlcIjogZC5sb29rdXAuY2xhc3NpZmllZCxcbi8vXHRcdFx0XHRcIkF1dGhvcmlzZWQgQnlcIjogZC5sb29rdXAuYXV0aG9yaXNlZCxcbi8vXHRcdFx0XHRcIk9yIG1heWJlXCI6IFwiVGhlIHBlcnNvbiB3aG8gY2xhc3NpZmllZCB0aGlzIHZhcmlhbnRcIixcbi8vXHRcdFx0XHRcIkFuZCBhbHNvXCI6IFwiVGhlIHBlb3BsZSB3aG8gdmVyaWZpZWQgaXRcIlxuLy9cdFx0XHR9O1xuLy9cdFx0XHRkcmF3VGFibGUocHJlZmVycmVkRGF0YSwgcHJlZmVycmVkQ1Zib3gpO1xuLy9cbi8vXG4vL1xuLy9cdFx0XHR2YXIgYnV0dG9ucyA9IGluZm9ib3guYXBwZW5kKFwiZGl2XCIpXG4vL1x0XHRcdFx0LmF0dHIoXCJpZFwiLCBcImN2LWJ1dHRvbnNcIilcbi8vXHRcdFx0XHQuY2xhc3NlZChcInhzLWNvbC00XCIsIHRydWUpXG4vL1x0XHRcdFx0LmNsYXNzZWQoXCJmYi1ib3hcIiwgdHJ1ZSk7XG4vL1xuLy9cbi8vXHRcdFx0dmFyIG5ld0NWID0gYnV0dG9ucy5hcHBlbmQoXCJkaXZcIikuY2xhc3NlZChcImZiLWJveFwiLCB0cnVlKTtcbi8vXG4vL1x0XHRcdG5ld0NWLmFwcGVuZChcImg0XCIpLnRleHQoXCJBZGQgYSBuZXcgQ1ZcIik7XG4vL1x0XHRcdG5ld0NWLmFwcGVuZChcImlucHV0XCIpXG4vL1x0XHRcdFx0LmF0dHIoXCJpZFwiLCBcIm5ld0NWY2NcIilcbi8vXHRcdFx0XHQuYXR0cihcInBsYWNlaG9sZGVyXCIsIFwiUGljayBhIENsaW5pY2FsIENvbnRleHRcIik7XG4vL1xuLy9cdFx0XHR2YXIgY2NBcnJheSA9IFtdO1xuLy9cdFx0XHRkLmxvb2t1cC5saXN0T2ZDQy5mb3JFYWNoKGZ1bmN0aW9uKGNjKXtcbi8vXHRcdFx0XHRjY0FycmF5LnB1c2goY2MuZGVzY3JpcHRpb24pO1xuLy9cdFx0XHR9KTtcbi8vXHRcdFx0Y29uc29sZS5sb2coY2NBcnJheSk7XG4vL1xuLy9cdFx0XHQkKFwiI25ld0NWY2NcIikuYXV0b2NvbXBsZXRlKHtzb3VyY2U6IGNjQXJyYXl9KTtcbi8vXG4vL1x0XHRcdG5ld0NWLmFwcGVuZChcImFcIilcbi8vXHRcdFx0XHQuYXR0cihcImhyZWZcIixcIiNub25lXCIpXG4vL1x0XHRcdFx0LmF0dHIoXCJvbmNsaWNrXCIsIFwiUGF0aE9TLnN2bGlzdC5jcmVhdGVDVihcIisgZC5zdi5pZCtcIilcIilcbi8vXHRcdFx0XHQudGV4dChcIkNyZWF0ZSBhIG5ldyBDVlwiKTtcbi8vXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXHRcdFx0YnV0dG9ucy5hcHBlbmQoXCJhXCIpLmF0dHIoXCJocmVmXCIsXCIjbmFcIikudGV4dChcIkFkZCBuZXcgQ1ZcIikuY2xhc3NlZChcImN2LWJ1dHRvblwiLCB0cnVlKTtcbi8vXHRcdFx0YnV0dG9ucy5hcHBlbmQoXCJiclwiKTtcbi8vXHRcdFx0YnV0dG9ucy5hcHBlbmQoXCJhXCIpLmF0dHIoXCJocmVmXCIsXCIjbmFcIikudGV4dChcIkFub3RoZXIgYnV0dG9uIHRvIGRvIGFub3RoZXIgdGhpbmdcIikuY2xhc3NlZChcImN2LWJ1dHRvblwiLCB0cnVlKTtcbi8vXHRcdFx0YnV0dG9ucy5hcHBlbmQoXCJiclwiKTtcbi8vXHRcdFx0YnV0dG9ucy5hcHBlbmQoXCJhXCIpLmF0dHIoXCJocmVmXCIsXCIjbmFcIikudGV4dChcIk1vcmUgYnV0dG9ucyFcIikuY2xhc3NlZChcImN2LWJ1dHRvblwiLCB0cnVlKTtcblxuXG5cblx0XHRcdGN2ZGl2LmFwcGVuZChcImgxXCIpLnRleHQoXCJDdXJhdGVkIFZhcmlhbnRzOlwiKTtcblx0XHRcdHZhciByb3cgPSBjdmRpdi5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0LmNsYXNzZWQoXCJyb3dcIiwgdHJ1ZSlcblx0XHRcdFx0LmF0dHIoXCJpZFwiLCBcImN2LWxpc3RcIik7XG5cblx0XHRcdHZhciB0YWJsZSA9IHJvdy5hcHBlbmQoJ3RhYmxlJyk7XG5cblx0XHRcdHZhciB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpLmFwcGVuZChcInRyXCIpO1xuXG5cdFx0XHR0aGVhZC5hcHBlbmQoXCJ0aFwiKS50ZXh0KFwiQ29udGV4dFwiKS5zdHlsZShcIndpZHRoXCIsIFwiMTUlXCIpO1xuXHRcdFx0dGhlYWQuYXBwZW5kKFwidGhcIikudGV4dChcIlJlcG9ydCBEZXNjcmlwdGlvblwiKTtcblx0XHRcdHRoZWFkLmFwcGVuZChcInRoXCIpLnRleHQoXCJFdmlkZW5jZSBEZXNjcmlwdGlvblwiKTtcblx0XHRcdHRoZWFkLmFwcGVuZChcInRoXCIpLnRleHQoXCJDbGFzc2lmaWNhdGlvblwiKTtcblxuXHRcdFx0dmFyIHRib2R5ID0gdGFibGUuYXBwZW5kKFwidGJvZHlcIik7XG5cdFx0XHR2YXIgY3YgPSBudWxsO1xuXHRcdFx0dmFyIGV2aWRlbmNlID0gbnVsbDtcblx0XHRcdGlmKGQuZ2VuZXJpYykge1xuXHRcdFx0XHRpZihkLmN1cnJlbnRDViAmJiBkLmN1cnJlbnRDVi5pZCAhPSBkLmdlbmVyaWMuaWQpIHtcblx0XHRcdFx0XHRhZGRDVnJvdyhkLmdlbmVyaWMsIGZhbHNlKTtcblx0XHRcdFx0XHRhZGRDVnJvdyhkLmN1cnJlbnRDViwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YWRkQ1Zyb3coZC5nZW5lcmljLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0ZC5vdGhlckNWcy5mb3JFYWNoKGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0XHRhZGRDVnJvdyhkYXRhLCBmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0ZnVuY3Rpb24gYWRkQ1Zyb3coZGF0YSwgaGlnaGxpZ2h0KXtcblx0XHRcdFx0dmFyIGxhYmVsID0gXCJHZW5lcmljXCIsXG5cdFx0XHRcdFx0aWQgPSBkYXRhLmlkO1xuXHRcdFx0XHRpZihkYXRhLmNsaW5Db250ZXh0KSB7XG5cdFx0XHRcdFx0bGFiZWwgPSBkLmxvb2t1cC5jb250ZXh0W2RhdGEuY2xpbkNvbnRleHQuaWRdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN2ID0gdGJvZHkuYXBwZW5kKFwidHJcIilcblx0XHRcdFx0XHQuY2xhc3NlZChcImN1cnJlbnQtY29udGV4dC1jdlwiLCBoaWdobGlnaHQpO1xuXHRcdFx0XHRpZihoaWdobGlnaHQpe1xuXHRcdFx0XHRcdGN2LmFwcGVuZChcInRkXCIpLmFwcGVuZChcImgyXCIpLmh0bWwoXCJDdXJyZW50IENvbnRleHQ8YnI+XCIpXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFwiYVwiKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJocmVmXCIsIFwiL1BhdGhPUy9jdXJWYXJpYW50L3Nob3c/aWQ9XCIgKyBkYXRhLmlkKVxuXHRcdFx0XHRcdFx0LnRleHQobGFiZWwpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN2LmFwcGVuZChcInRkXCIpXG5cdFx0XHRcdFx0XHQuYXBwZW5kKFwiYVwiKVxuXHRcdFx0XHRcdFx0LmF0dHIoXCJocmVmXCIsIFwiL1BhdGhPUy9jdXJWYXJpYW50L3Nob3c/aWQ9XCIgKyBkYXRhLmlkKVxuXHRcdFx0XHRcdFx0LnRleHQobGFiZWwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGN2LmFwcGVuZChcInRkXCIpLmFwcGVuZChcInRleHRhcmVhXCIpLmF0dHIoXCJyZWFkb25seVwiLCB0cnVlKS5zdHlsZShcIndpZHRoXCIsIFwiMTAwJVwiKS50ZXh0KGRhdGEucmVwb3J0RGVzYyk7XG5cdFx0XHRcdGN2LmFwcGVuZChcInRkXCIpLmFwcGVuZChcInRleHRhcmVhXCIpLmF0dHIoXCJyZWFkb25seVwiLCB0cnVlKS5zdHlsZShcIndpZHRoXCIsIFwiMTAwJVwiKS50ZXh0KGRhdGEuZXZpZGVuY2UuanVzdGlmaWNhdGlvbik7XG5cblx0XHRcdFx0ZXZpZGVuY2UgPSBjdi5hcHBlbmQoXCJ0ZFwiKTtcblxuXHRcdFx0XHR2YXIgcG1DbGFzcyA9IGRhdGEucG1DbGFzcy5zcGxpdChcIjpcIilbMF07XG5cdFx0XHRcdGV2aWRlbmNlLmFwcGVuZChcInBcIilcblx0XHRcdFx0XHQudGV4dChkYXRhLnBtQ2xhc3MpXG5cdFx0XHRcdFx0LmNsYXNzZWQoXCJjdmxhYmVsIGN2LVwiK3BtQ2xhc3MsIHRydWUpO1xuXG5cdFx0XHRcdHZhciBjb3VudCA9IDA7XG5cblx0XHRcdFx0dmFyIGJ1dHRvbiA9IGV2aWRlbmNlLmFwcGVuZChcImFcIilcblx0XHRcdFx0XHQuYXR0cihcImhyZWZcIiwgXCIjbm9uZVwiKVxuXHRcdFx0XHRcdC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdFx0Y29uc29sZS5sb2coXCJjbGljY2NraW5nZ2dnZ1wiKTtcblx0XHRcdFx0XHRcdCQoXCIjZXZpZGVuY2UtbGlzdC1cIitpZCkudG9nZ2xlQ2xhc3MoXCJoaWRkZW5cIik7XG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0dmFyIGxpc3QgPSBldmlkZW5jZS5hcHBlbmQoXCJ1bFwiKVxuXHRcdFx0XHRcdC5hdHRyKFwiaWRcIiwgXCJldmlkZW5jZS1saXN0LVwiK2lkKVxuXHRcdFx0XHRcdC5jbGFzc2VkKFwiaGlkZGVuXCIsIHRydWUpO1xuXG5cdFx0XHRcdE9iamVjdC5rZXlzKFBhdGhPUy5zdmxpc3QuZXZpZGVuY2UpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcblx0XHRcdFx0XHRpZihkYXRhLmV2aWRlbmNlW2tleV0pIHtcblx0XHRcdFx0XHRcdGNvdW50Kys7XG5cdFx0XHRcdFx0XHRsaXN0LmFwcGVuZCgnbGknKS5odG1sKFBhdGhPUy5zdmxpc3QuZXZpZGVuY2Vba2V5XSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnV0dG9uLnRleHQoXCJTaG93IEV2aWRlbmNlIChcIitjb3VudCtcIilcIik7XG5cdFx0XHR9XG5cblxuXG5cblxuXG5cblxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvL1xuXHRcdFx0Ly92YXIgbmFtZSA9IHJvdy5hcHBlbmQoXCJkaXZcIikuY2xhc3NlZChcImNvbC14cy0xIGZiLWJveFwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vXG5cdFx0XHQvL3ZhciBsZWZ0ID0gcm93LmFwcGVuZChcImRpdlwiKS5jbGFzc2VkKFwiY29sLXhzLTMgZmItYm94XCIsIHRydWUpO1xuICAgICAgICAgICAgLy9cblx0XHRcdC8vdmFyIG1pZGRsZSA9IHJvdy5hcHBlbmQoXCJkaXZcIikuY2xhc3NlZChcImNvbC14cy0zIGZiLWJveFwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vXG5cdFx0XHQvL3ZhciByaWdodCA9IHJvdy5hcHBlbmQoXCJkaXZcIikuY2xhc3NlZChcImNvbC14cy01IGZiLWJveFwiLCB0cnVlKTtcbiAgICAgICAgICAgIC8vXG5cdFx0XHQvL25hbWUuYXBwZW5kKFwiaDRcIikudGV4dChcIk5hbWVcIilcblx0XHRcdC8vXHQuY2xhc3NlZChcImN2LWhlYWRlclwiLCB0cnVlKTtcblx0XHRcdC8vbGVmdC5hcHBlbmQoXCJoNFwiKS50ZXh0KFwiR2VuZXJpYyBDdXJhdGVkIFZhcmlhbnRcIilcblx0XHRcdC8vXHQuY2xhc3NlZChcImN2LWhlYWRlclwiLCB0cnVlKTtcblx0XHRcdC8vbWlkZGxlLmFwcGVuZChcImg0XCIpLnRleHQoXCJQcmVmZXJyZWQgQ3VyYXRlZCBWYXJpYW50XCIpXG5cdFx0XHQvL1x0LmNsYXNzZWQoXCJjdi1oZWFkZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAvL1xuXHRcdFx0Ly9yaWdodC5hcHBlbmQoXCJoNFwiKS50ZXh0KFwiT3RoZXIgQ3VyYXRlZCBWYXJpYW50c1wiKVxuXHRcdFx0Ly9cdC5jbGFzc2VkKFwiY3YtaGVhZGVyXCIsIHRydWUpO1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvL1xuXHRcdFx0Ly9uYW1lLmFwcGVuZChcImRpdlwiKS5hcHBlbmQoXCJwXCIpLnRleHQoXCJDbGluaWNhbCBDb250ZXh0XCIpLmNsYXNzZWQoXCJjYy1oZWFkZXJcIiwgdHJ1ZSk7XG5cdFx0XHQvL25hbWUuYXBwZW5kKFwiZGl2XCIpLmFwcGVuZChcInBcIikudGV4dChcIlJlcG9ydCBEZXNjcmlwdGlvblwiKS5jbGFzc2VkKFwicmVwb3J0XCIsIHRydWUpO1xuXHRcdFx0Ly9uYW1lLmFwcGVuZChcImRpdlwiKS5hcHBlbmQoXCJwXCIpLnRleHQoXCJFdmlkZW5jZVwiKS5jbGFzc2VkKFwiZXZpZGVuY2VcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vXG5cdFx0XHQvL2RyYXdDVnMoXG5cdFx0XHQvL1x0bGVmdCwgLy8uYXBwZW5kKFwidGFibGVcIikuYXBwZW5kKFwidGJvZHlcIikuYXBwZW5kKFwidHJvd1wiKS5hcHBlbmQoXCJ0ZFwiKS5hcHBlbmQoXCJkaXZcIiksXG5cdFx0XHQvL1x0ZC5nZW5lcmljLFxuXHRcdFx0Ly9cdGQubG9va3VwXG5cdFx0XHQvLyk7XG4gICAgICAgICAgICAvL1xuXHRcdFx0Ly9kcmF3Q1ZzKFxuXHRcdFx0Ly9cdG1pZGRsZSwgLy8uYXBwZW5kKFwidGFibGVcIikuYXBwZW5kKFwidGJvZHlcIikuYXBwZW5kKFwidHJvd1wiKS5hcHBlbmQoXCJ0ZFwiKS5hcHBlbmQoXCJkaXZcIiksXG5cdFx0XHQvL1x0ZC5wcmVmZXJyZWQsXG5cdFx0XHQvL1x0ZC5sb29rdXBcblx0XHRcdC8vKTtcbiAgICAgICAgICAgIC8vXG5cdFx0XHQvL3ZhciBvdGhlckNWcyA9IHJpZ2h0LmFwcGVuZChcInRhYmxlXCIpLmFwcGVuZChcInRib2R5XCIpLmFwcGVuZChcInRyb3dcIik7XG5cdFx0XHQvL2Qub3RoZXJDVnMuZm9yRWFjaChmdW5jdGlvbihjdil7XG5cdFx0XHQvL1x0ZHJhd0NWcyhcblx0XHRcdC8vXHRcdG90aGVyQ1ZzLmFwcGVuZChcInRkXCIpLmNsYXNzZWQoXCJjdi10ZFwiLCB0cnVlKS5hcHBlbmQoXCJkaXZcIiksXG5cdFx0XHQvL1x0XHRjdixcblx0XHRcdC8vXHRcdGQubG9va3VwXG5cdFx0XHQvL1x0KTtcblx0XHRcdC8vfSk7XG4gICAgICAgICAgICAvL1xuXG5cblxuXHRcdH19KTtcblxuXHRcdGZ1bmN0aW9uIGRyYXdDVnMoZGl2LCBjdiwgbG9va3VwKSB7XG5cdFx0XHRjb25zb2xlLmxvZyhjdik7XG5cblx0XHRcdGRpdi5hdHRyKFwiaWRcIiwgXCJjdi1cIitjdi5pZCk7XG5cblx0XHRcdHZhciBjYyA9IFwiR2VuZXJpY1wiO1xuXHRcdFx0aWYgKGN2LmNsaW5Db250ZXh0ICE9PSBudWxsKSB7XG5cdFx0XHRcdGNjID0gbG9va3VwLmNvbnRleHRbY3YuY2xpbkNvbnRleHQuaWRdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGluaWNhbCBDb250ZXh0Li4uXG5cdFx0XHRkaXYuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdC5hcHBlbmQoXCJwXCIpXG5cdFx0XHRcdC50ZXh0KGNjKTtcblxuXHRcdFx0ZGl2LmFwcGVuZChcImFcIilcblx0XHRcdFx0LmF0dHIoXCJocmVmXCIsXCIjbmFcIilcblx0XHRcdFx0LmF0dHIoXCJvbmNsaWNrXCIsIFwiUGF0aE9TLnN2bGlzdC5zYXZlQ1YoXCIrIGN2LmlkICtcIilcIilcblx0XHRcdFx0LnRleHQoXCJTYXZlIENWXCIpXG5cdFx0XHRcdC5jbGFzc2VkKFwiY3YtYnV0dG9uXCIsIHRydWUpO1xuXG5cdFx0XHQvLyBSZXBvcnQgRGVzY3JpcHRpb24uLi5cblx0XHRcdGRpdi5hcHBlbmQoXCJkaXZcIilcblx0XHRcdFx0LmFwcGVuZChcInRleHRhcmVhXCIpXG5cdFx0XHRcdC5jbGFzc2VkKFwicmVwb3J0XCIsIHRydWUpXG5cdFx0XHRcdC5odG1sKGN2LnJlcG9ydERlc2MpO1xuXG5cdFx0XHQvLyBFdmlkZW5jZSBKdXN0aWZpY2F0aW9uLi4uXG5cdFx0XHRkaXYuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdC5hcHBlbmQoXCJ0ZXh0YXJlYVwiKVxuXHRcdFx0XHQuY2xhc3NlZChcImV2aWRlbmNlXCIsIHRydWUpXG5cdFx0XHRcdC5odG1sKGN2LmV2aWRlbmNlLmp1c3RpZmljYXRpb24pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGRyYXdUYWJsZShpbmZvLCBpbmZvYm94KXtcblx0XHRcdGluZm9ib3guc2VsZWN0KFwidGFibGVcIikucmVtb3ZlKCk7XG5cblx0XHRcdHZhciB0YWJsZSA9IGluZm9ib3guYXBwZW5kKFwidGFibGVcIilcblx0XHRcdFx0LmF0dHIoXCJpZFwiLCBcInN2SW5mb1RhYmxlXCIpXG5cdFx0XHRcdC5jbGFzc2VkKFwiaW5mb1RhYmxlXCIsIHRydWUpO1xuXG5cdFx0XHR2YXIgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuXHRcdFx0T2JqZWN0LmtleXMoaW5mbykuZm9yRWFjaChmdW5jdGlvbihyb3cpe1xuXHRcdFx0XHR2YXIgciA9IHRib2R5LmFwcGVuZChcInRyXCIpO1xuXHRcdFx0XHRyLmFwcGVuZChcInRkXCIpLmh0bWwocm93KS5jbGFzc2VkKFwicHJvcGVydHktbGFiZWxcIiwgdHJ1ZSk7XG5cdFx0XHRcdHIuYXBwZW5kKFwidGRcIikuaHRtbChpbmZvW3Jvd10pLmNsYXNzZWQoXCJwcm9wZXJ0eS12YWx1ZVwiLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXG5cblxuXHRcdC8vVHVybiBvZmYgaG90a2V5cywgYW5kIG1ha2UgXCJlc2NcIiBoaWRlIHRoZSBtZW51XG5cdFx0UGF0aE9TLmhvdGtleXMub2ZmKCk7XG5cdFx0JCgnYm9keScpLm9uKCdrZXlkb3duJywgZnVuY3Rpb24oZSl7XG5cdFx0XHRpZihlICYmIGUua2V5Q29kZSAmJiBlLmtleUNvZGUgPT0gMjcgJiYgISQoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkuaXMoXCJpbnB1dFwiKSAmJiAhJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyhcInRleHRhcmVhXCIpICYmICFlLmFsdEtleSAmJiAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkpe1xuXHRcdFx0XHRQYXRoT1Muc3ZsaXN0LmNsb3NlQ1YoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblx0Y2xvc2VDVjogZnVuY3Rpb24oKXtcblx0XHRjb25zb2xlLmxvZyhcImNsb3NpbmcgQ1YhXCIpO1xuXG5cdFx0Ly8gR2V0IHJpZCBvZiB0aGUgbWVudVxuXHRcdGQzLnNlbGVjdChcIiNvdmVybGF5XCIpLnJlbW92ZSgpO1xuXHRcdC8vIEJyaW5nIGJhY2sgdGhlIGhvdGtleXMuLi5cblx0XHRQYXRoT1MuaG90a2V5cy5pbml0KCk7XG5cblx0fVxufTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuUGF0aE9TLmJ1aWxkQmxvY2sgPSBmdW5jdGlvbiAoZGl2LCBkYXRhKXtcblx0ZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKGQpe1xuXHRcdHZhciBsaW5lID0gZGl2LmFwcGVuZCgncCcpO1xuXG5cdFx0aWYoZC5saW5rICYmIGQubGluayAhPT0gJycpIHtcblx0XHRcdGxpbmUuYXBwZW5kKCdzcGFuJykuY2xhc3NlZCgnYm9sZCcsIHRydWUpLnRleHQoZC50aXRsZStcIjogXCIpO1xuXHRcdFx0bGluZS5odG1sKGxpbmUuaHRtbCgpKyc8YSBocmVmPVwiJytkLmxpbmsrJ1wiPicrIGQud29yZHMrJzwvYT4nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGluZS5hcHBlbmQoJ3NwYW4nKS5jbGFzc2VkKCdib2xkJywgdHJ1ZSkudGV4dChkLnRpdGxlK1wiOiBcIik7XG5cdFx0XHRsaW5lLmh0bWwobGluZS5odG1sKCkrZC53b3Jkcyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cblxuXG5QYXRoT1MuY2xhc3NpZnkgPSBmdW5jdGlvbiAoZCl7XG5cdHJldHVybiBkLnRvTG93ZXJDYXNlKCkucmVwbGFjZShcIiBcIiwgXCItXCIpO1xufTtcblxuUGF0aE9TLnBhcmFtcyA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgcGFyYW1zID0ge307XG5cdHZhciBzdHJpbmcgPSB3aW5kb3cubG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKTtcblx0dmFyIGFyciA9IHN0cmluZy5zcGxpdChcIiZcIik7XG5cblx0YXJyLmZvckVhY2goZnVuY3Rpb24ocSl7XG5cdFx0aWYocS5pbmRleE9mKFwiPVwiKSA+IDApIHtcblx0XHRcdHZhciBzdHVmZiA9IHEuc3BsaXQoXCI9XCIpLFxuXHRcdFx0XHRuYW1lID0gc3R1ZmZbMF0sXG5cdFx0XHRcdGRhdGEgPSBkZWNvZGVVUklDb21wb25lbnQoc3R1ZmZbMV0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG5cblx0XHRcdHBhcmFtc1tuYW1lXSA9IGRhdGE7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4gcGFyYW1zO1xufTtcblxuUGF0aE9TLmV2aWRlbmNlID0ge1xuXHRiZW5pZ25BbG9uZUdtYWY6IFwiQmVuaWduIFN0YW5kLWFsb25lIEdtYWZcIixcblx0YmVuaWduQWxvbmVIZWFsdGh5OiBcIkJlbmlnbiBTdGFuZC1hbG9uZSBIZWFsdGh5XCIsXG5cdGJlbmlnblN0cm9uZ0Nhc2U6IFwiQmVuaWduIFN0YW5kLWFsb25lIFN0cm9uZy1jYXNlXCIsXG5cdGJlbmlnblN0cm9uZ0Nvc2VnOiBcIkJlbmlnbiBTdGFuZC1hbG9uZSBDb3NlZ1wiLFxuXHRiZW5pZ25TdHJvbmdGdW5jdGlvbjogXCJCZW5pZ24gU3Ryb25nIEZ1bmN0aW9uXCIsXG5cdGJlbmlnblN1cHBvcnRJbnNpbGljbzogXCJCZW5pZ24gU3VwcG9ydCBJbnNpbGljb1wiLFxuXHRiZW5pZ25TdXBwb3J0THNkYjogXCJCZW5pZ24gU3VwcG9ydCBMb2NhbCBTZXF1ZW5jZSBEYXRhYmFzZVwiLFxuXHRiZW5pZ25TdXBwb3J0UGF0aDogXCJCZW5pZ24gU3VwcG9ydCBQYXRob2xvZ3lcIixcblx0YmVuaWduU3VwcG9ydFNwZWN0cnVtOiBcIkJlbmlnbiBTdXBwb3J0IFNwZWN0cnVtXCIsXG5cdGJlbmlnblN1cHBvcnRWYXJpYWJsZTogXCJCZW5pZ24gU3VwcG9ydCBWYXJpYWJsZVwiLFxuXHRwYXRoQWxvbmVLbm93bjogXCJQYXRob2xvZ3kgU3RhbmQtYWxvbmUgS25vd25cIixcblx0cGF0aEFsb25lVHJ1bmNhdGluZzogXCJQYXRob2xvZ3kgU3RhbmQtYWxvbmUgVHJ1bmNhdGluZ1wiLFxuXHRwYXRoU3Ryb25nQ2FzZTogXCJQYXRob2xvZ3kgU3Ryb25nIENhc2VcIixcblx0cGF0aFN0cm9uZ0Nvc2VnOiBcIlBhdGhvbG9neSBTdHJvbmcgQ29zZWdcIixcblx0cGF0aFN0cm9uZ0Z1bmN0aW9uOiBcIlBhdGhvbG9neSBTdHJvbmcgRnVuY3Rpb25cIixcblx0cGF0aFN1cHBvcnRDb3NlZzogXCJQYXRob2xvZ3kgU3VwcG9ydCBDb3NlZ1wiLFxuXHRwYXRoU3VwcG9ydEdlbmU6IFwiUGF0aG9sb2d5IFN1cHBvcnQgR2VuZVwiLFxuXHRwYXRoU3VwcG9ydEdtYWY6IFwiUGF0aG9sb2d5IFN1cHBvcnQgR21hZlwiLFxuXHRwYXRoU3VwcG9ydEhvdHNwb3Q6IFwiUGF0aG9sb2d5IFN1cHBvcnQgSG90c3BvdFwiLFxuXHRwYXRoU3VwcG9ydEluZGVsOiBcIlBhdGhvbG9neSBTdXBwb3J0IEluZGVsXCIsXG5cdHBhdGhTdXBwb3J0SW5zaWxpY286IFwiUGF0aG9sb2d5IFN1cHBvcnQgSW5zaWxpY29cIixcblx0cGF0aFN1cHBvcnRMc2RiOiBcIlBhdGhvbG9neSBTdXBwb3J0IExvY2FsIFNlcXVlbmNlIERhdGFiYXNlXCIsXG5cdHBhdGhTdXBwb3J0Tm92ZWxNaXNzZW5zZTogXCJQYXRob2xvZ3kgU3VwcG9ydCBOb3ZlbCBNaXNzZW5zZVwiLFxuXHRwYXRoU3VwcG9ydFNwZWN0cnVtOiBcIlBhdGhvbG9neSBTdXBwb3J0IFNwZWN0cnVtXCJcbn07XG5cblxuLy8gQWRkIGhvdGtleXMgdG8gYW55IFBhdGhPUyBwYWdlLlxuLy8gaW5pdCBpcyBjYWxsZWQgb25jZSBpbiBsYXlvdXRzL21haW4uZ3NwXG4vLyB1c2UgUGF0aE9TLmhvdGtleXMub2ZmKCk7IHRvIHR1cm4gb2ZmIHRoZSBob3RrZXlzIG9uIGEgcGFnZS5cbiBQYXRoT1MuaG90a2V5cyA9IHtcbiBcdGtleXM6IHtcblx0XHQyNzogZnVuY3Rpb24oKXtcblx0XHRcdGQzLnNlbGVjdEFsbChcIi50YWdkaXYgLnRvb2x0aXAuZWRpdFwiKS5jbGFzc2VkKFwiZWRpdFwiLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuIFx0YWRkOiBmdW5jdGlvbihrZXksIGFjdGlvbil7XG4gXHRcdHRoaXMua2V5c1trZXldID0gYWN0aW9uO1xuIFx0fSxcbiBcdG9mZjogZnVuY3Rpb24oKXtcbiBcdFx0JCgnYm9keScpLm9mZihcImtleWRvd25cIik7XG4gXHR9LFxuIFx0aW5pdDogZnVuY3Rpb24oKXtcbiBcdFx0dmFyIGtleXMgPSB0aGlzLmtleXM7XG5cdFx0JCgnYm9keScpLm9uKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKXtcblx0XHRcdGlmKGUgJiYgZS5rZXlDb2RlICYmIGtleXNbZS5rZXlDb2RlXSAmJiAhJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyhcImlucHV0XCIpICYmICEkKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpLmlzKFwidGV4dGFyZWFcIikgJiYgIWUuYWx0S2V5ICYmICFlLm1ldGFLZXkgJiYgIWUuY3RybEtleSl7XG5cdFx0XHRcdFx0a2V5c1tlLmtleUNvZGVdKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG4gXHR9LFxuIFx0dGVzdE1vZGU6IGZ1bmN0aW9uKCl7XG4gXHRcdHZhciBrZXlzID0gdGhpcy5rZXlzO1xuXHRcdCQoJ2JvZHknKS5vbihcImtleWRvd25cIiwgZnVuY3Rpb24oZSl7XG5cdFx0XHRpZihlICYmIGUua2V5Q29kZSAmJiAhJChkb2N1bWVudC5hY3RpdmVFbGVtZW50KS5pcyhcImlucHV0XCIpICYmICFlLmFsdEtleSAmJiAhZS5tZXRhS2V5ICYmICFlLmN0cmxLZXkpe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiWW91IHB1c2hlZDogXCIrZS5rZXlDb2RlKTtcblx0XHRcdFx0aWYgKGtleXNbZS5rZXlDb2RlXSkge1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFwiSXQgaGFzIHRoaXMgZnVuY3Rpb246XCIpO1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGtleXNbZS5rZXlDb2RlXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTsgXG4gXHR9XG4gfTtcblxuXG5QYXRoT1MudGltZVNpbmNlID0gZnVuY3Rpb24gKGRhdGUpIHtcblx0dmFyIHZhbCA9IFwiXCIsXG5cdFx0ZCA9IERhdGUucGFyc2UoZGF0ZSksXG5cdFx0YyA9IERhdGUubm93KCksXG5cdFx0aSA9IGMgLSBkO1xuXG5cdGlmKCBkID4gMCApIHtcblx0XHRpZiAoaSA8IDM2MDAwMDAgKSB7XG5cdFx0XHR2YWwgPSBNYXRoLmZsb29yKGkgLyA2MDAwMCkgKyBcIm1cIjtcblx0XHR9IGVsc2UgaWYgKGkgPCA4NjQwMDAwMCApIHtcblx0XHRcdHZhbCA9IE1hdGguZmxvb3IoaSAvIDM2MDAwMDApICsgXCJoXCI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhbCA9IE1hdGguZmxvb3IoaSAvIDg2NDAwMDAwKSArIFwiZFwiO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59O1xuXG5cblxuXG4vLyBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBjaGVja2JveCB0byB5b3VyIHBhZ2UgdGhhdCB1c2VzIGxvY2FsIHN0b3JhZ2Vcbi8vIFRoZSBvcHRpb24gd2lsbCBwZXJzaXN0IG92ZXIgc2NyZWVuIHJlZnJlc2hlcy5cbi8vIFRoaXMgYWxsb3dzIHVzIHRvIGZsaXAgYSBjbGFzcyBvbiBhIHNldCBvZiB0aGluZ3MuXG4vLyBWZXJ5IHVzZWZ1bCBmb3IgY2hhbmdpbmcgY29sb3VycyBvciBoaWRpbmcgZWxlbWVudHMuXG4vL1xuLy8gZGl2ID0gd2hlcmUgeW91IHdhbnQgdGhlIGNoZWNrYm94IHRvIGdvXG4vLyBsYWJlbCA9IHRoZSBsYWJlbCBvZiB0aGUgY2hlY2tib3hcbi8vIGtleSA9IHRoZSBjbGFzcyB0aGF0IHdlIGxvb2sgZm9yLCB3aGljaCB3ZSBwdXQgYSB0b2dnbGUgb24uXG4vLyBcdFx0VGhlIGFkZGVkIGNsYXNzIHdpbGwgYmUgY2FsbGVkIFwia2V5XCItdG9nZ2xlXG4vLyB2YWx1ZSA9IGRlZmF1bHQgdmFsdWUgb2YgdGhlIGNoZWNrYm94IChvcHRpb25hbCwgZGVmYXVsdCBpcyBmYWxzZSlcblxuXG5QYXRoT1MuYWRkT3B0aW9uID0gZnVuY3Rpb24oZGl2LCBsYWJlbCwga2V5LCB2YWx1ZSl7XG5cdHZhciBjaGVja2JveCA9IGRpdi5hcHBlbmQoJ2xhYmVsJyk7XG5cdGNoZWNrYm94LmFwcGVuZCgnaW5wdXQnKVxuXHRcdC5hdHRyKCdjbGFzcycsICdvcHRpb24nKVxuXHRcdC5hdHRyKCdpZCcsICdvcHRpb24tJytrZXkpXG5cdFx0LmF0dHIoJ3R5cGUnLCAnY2hlY2tib3gnKTtcblx0Y2hlY2tib3guaHRtbChjaGVja2JveC5odG1sKCkrXCIgXCIrbGFiZWwrXCI8YnI+XCIpO1xuXHRjaGVja2JveC5vbignY2hhbmdlJywgZnVuY3Rpb24oKXtcblx0XHQkKCcuJytrZXkpLnRvZ2dsZUNsYXNzKGtleSsnLXRvZ2dsZScpO1xuXHRcdGxvY2FsU3RvcmFnZVtrZXkrJy1vcHRpb24nXSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3B0aW9uLVwiK2tleSkuY2hlY2tlZDtcblx0fSk7XG5cblxuXHQvLyBTZXQgaXQgdG8gdHJ1ZSBpZiB0aGUgZGVmYXVsdCBpcyB0cnVlIG9yIGlmIHRoZSBmbGFnIGhhcyBiZWVuIHNldCB0byB0cnVlLlxuXHRpZih2YWx1ZSkge1xuXHRcdGlmKHR5cGVvZiBsb2NhbFN0b3JhZ2Vba2V5Kyctb3B0aW9uJ10gPT0gJ3VuZGVmaW5lZCcgfHxcblx0XHRcdFx0bG9jYWxTdG9yYWdlW2tleSsnLW9wdGlvbiddID09PSB0cnVlIHx8XG5cdFx0XHRcdGxvY2FsU3RvcmFnZVtrZXkrJy1vcHRpb24nXSA9PSAndHJ1ZSdcblx0XHQpe1xuXHRcdFx0Y2hlY2tib3guc2VsZWN0KCdpbnB1dCcpLmF0dHIoJ2NoZWNrZWQnLCB2YWx1ZSk7XG5cdFx0XHRkMy5zZWxlY3RBbGwoJy4nK2tleSkuY2xhc3NlZChrZXkrJy10b2dnbGUnLCB0cnVlKTtcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0aWYodHlwZW9mIGxvY2FsU3RvcmFnZVtrZXkrJy1vcHRpb24nXSAhPSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0bG9jYWxTdG9yYWdlW2tleSsnLW9wdGlvbiddID09PSB0cnVlIHx8XG5cdFx0XHRsb2NhbFN0b3JhZ2Vba2V5Kyctb3B0aW9uJ10gPT0gJ3RydWUnXG5cdFx0KXtcblx0XHRcdGNoZWNrYm94LnNlbGVjdCgnaW5wdXQnKS5hdHRyKCdjaGVja2VkJywgdHJ1ZSk7XG5cdFx0XHRkMy5zZWxlY3RBbGwoJy4nK2tleSkuY2xhc3NlZChrZXkrJy10b2dnbGUnLCB0cnVlKTtcblx0XHR9XG5cdH1cblx0Ly8gVGhlIGxvZ2ljIGhlcmUgY291bGQgcHJvYmFibHkgYmUgbW9yZSBlbGVnYW50LCBidXQgSSBjYmYgdGhpbmtpbmcgcmlnaHQgbm93LlxuXG59O1xuXG5QYXRoT1MuaGlzdG9yeSA9IHtcblx0anNvbjogW10sXG5cblx0LyoqXG5cdCAqIEFkZCBhIHdlYnBhZ2UgdG8gdGhlIGhpc3Rvcnlcblx0ICpcblx0ICogZXhhbXBsZTpcblx0ICogUGF0aE9TLmhpc3RvcnkuYWRkKHtcblx0ICpcdHRpdGxlOiBkb2N1bWVudC50aXRsZSxcblx0ICpcdHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG5cdCAqXHR0aW1lOiBEYXRlKClcblx0ICogQHBhcmFtIHRpdGxlLCB1cmwsIHRpbWVcbiAgICAgKi9cblx0YWRkOiBmdW5jdGlvbiAoZCl7XG5cdFx0UGF0aE9TLmhpc3RvcnkuanNvbi5mb3JFYWNoKGZ1bmN0aW9uKG9sZCwgaSl7XG5cdFx0XHRpZihvbGQudGl0bGUgPT0gZC50aXRsZSl7XG5cdFx0XHRcdFBhdGhPUy5oaXN0b3J5Lmpzb24uc3BsaWNlKGksIDEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdFBhdGhPUy5oaXN0b3J5Lmpzb24ucHVzaChkKTtcblx0XHRpZihQYXRoT1MuaGlzdG9yeS5qc29uLmxlbmd0aCA+IDUwKSB7XG5cdFx0XHRQYXRoT1MuaGlzdG9yeS5qc29uID0gUGF0aE9TLmhpc3RvcnkuanNvbi5zbGljZSgyMCk7XG5cdFx0fVxuXHRcdFBhdGhPUy5kYXRhLnNhdmUoXCJoaXN0b3J5XCIsIFBhdGhPUy5oaXN0b3J5Lmpzb24pO1xuXHR9LFxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0UGF0aE9TLmhpc3RvcnkuanNvbiA9IFtdO1xuXHRcdFBhdGhPUy5kYXRhLmNsZWFyKFwiaGlzdG9yeVwiKTtcblx0fSxcblx0c2hvdzogZnVuY3Rpb24oZCkge1xuXHRcdHZhciBhcnIgPSBQYXRoT1MuaGlzdG9yeS5qc29uO1xuXHRcdHZhciBuID0gZCB8fCAxMDtcblx0XHRyZXR1cm4gKGFyci5sZW5ndGggPCBuID8gYXJyIDogYXJyLnNsaWNlKGFyci5sZW5ndGggLSBuKSkucmV2ZXJzZSgpO1xuXHR9LFxuXHRtb3JlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYXJyID0gUGF0aE9TLmhpc3RvcnkuanNvbjtcblx0XHR2YXIgbiA9IDUwO1xuXG5cdFx0cmV0dXJuIChhcnIubGVuZ3RoIDwgbiA/IGFyciA6IGFyci5zbGljZShhcnIubGVuZ3RoIC0gbikpLnJldmVyc2UoKS5zbGljZSgxMCk7XG5cdH0sXG5cdGluaXQ6IGZ1bmN0aW9uKCl7XG5cdFx0UGF0aE9TLmhpc3RvcnkuanNvbiA9IFBhdGhPUy5kYXRhLmxvYWQoXCJoaXN0b3J5XCIsIFtdKTtcblx0fVxufTtcblxuLyogSW5pdGlhbGlzZSBzdHVmZiwgbGlrZTpcbiAqIEhvdGtleXMsXG4gKiBIaXN0b3J5XG4gKlxuICpcbiAqXG4gKlxuICpcbiAqL1xuXG5cblxuLy8gU2FmdGV5IGlzIGZvciBzdG9wcGluZyBwZW9wbGUgbGVhdmluZyB0aGUgcGFnZSBpZiB0aGV5J3ZlIHR5cGVkIHN0dWZmLlxuLy8gVG8gYmUgaW1wbGltZW50ZWRcblBhdGhPUy5zYWZldHkgPSB7XG5cdGNoYW5nZTogZmFsc2UsXG5cdHNhdmVkOiBmYWxzZSxcblx0aW5pdDogZnVuY3Rpb24oKXtcblx0XHQkKCd0ZXh0YXJlYSxpbnB1dCcpLmtleXVwKGZ1bmN0aW9uKCl7XG5cdFx0XHRQYXRoT1Muc2FmZXR5LmNoYW5nZSA9IHRydWU7XG5cdFx0fSk7XG5cblx0XHQkKCcuc2F2ZWJ1dHRvbicpLm9uKCdjbGljaycsZnVuY3Rpb24oKXtcblx0XHRcdFBhdGhPUy5zYWZldHkuc2F2ZWQgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0d2luZG93Lm9uYmVmb3JldW5sb2FkID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihQYXRoT1Muc2FmZXR5LmNoYW5nZSAmJiAhUGF0aE9TLnNhZnRleS5zYXZlZCkge1xuXHRcdFx0XHRyZXR1cm4gJ1Rlc3RpbmcnO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn07XG5cbi8vIFRoaXMgcGFydCBvZiB0aGUgUGF0aE9TIGxpYnJhcnkgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIGEgc3RhbmRhcmRpc2VkIHRhZyBzeXN0ZW1cbi8vIFBlcmhhcHMgYSB0YWdsaWIgbWlnaHQgYmUgbW9yZSBhcHByb3ByaWF0ZT8gSSdtIG5vdCBzdXJlIHdoaWNoIGlzIGJldHRlci5cbi8vIEknbSBqdXN0IGdvaW5nIHRvIGdldCBpdCB3b3JraW5nIGZpcnN0LCB0aGVuIG9wdGltaXNlIGxhdGVyLlxuLy8gREtHTSAzMCBKdW5lIDIwMTZcblBhdGhPUy50YWdzID0ge1xuXHRjdXJyZW50X29iamVjdDogZmFsc2UsXG5cdHVwZGF0ZV9vYmplY3Q6IGZ1bmN0aW9uKGQpIHtcblx0XHRQYXRoT1MudGFncy5jdXJyZW50X29iamVjdCA9IGQ7XG5cdFx0dmFyIHBhcmFtcyA9IHtcblx0XHRcdHR5cGU6IFBhdGhPUy5jb250cm9sbGVyLFxuXHRcdFx0aWQ6IGRcblx0XHR9O1xuXHRcdGlmKHBhcmFtcy50eXBlICYmIGQpIHtcblx0XHRcdCQuYWpheCh7XG5cdFx0XHRcdHR5cGU6ICdHRVQnLFxuXHRcdFx0XHR1cmw6IFwiL1BhdGhPUy90YWcvZ2V0VGFncz9cIiArICQucGFyYW0ocGFyYW1zKSxcblx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24gKGQpe1xuXHRcdFx0XHRcdGNvbnNvbGUubG9nKGQpO1xuXHRcdFx0XHRcdGQzLnNlbGVjdChcIiN0YWdzXCIpLnN0eWxlKCdkaXNwbGF5JywnJyk7XG5cdFx0XHRcdFx0JChcIiNvYmplY3RfaWRcIikudGV4dChkLm5hbWUpO1xuXHRcdFx0XHRcdGQzLnNlbGVjdEFsbChcIiN0YWdzIC50YWdkaXZcIikucmVtb3ZlKCk7XG5cdFx0XHRcdFx0aWYoZC50YWdzKSB7XG5cdFx0XHRcdFx0XHRkLnRhZ3MuZm9yRWFjaChmdW5jdGlvbih0YWcpe1xuXHRcdFx0XHRcdFx0XHRQYXRoT1MudGFncy5kcmF3VGFnKGQzLnNlbGVjdChcIiN0YWdzIC5mYi1ib3hcIiksIHRhZywgdHJ1ZSk7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0UGF0aE9TLnRhZ3MubnVsbE9iamVjdChkMy5zZWxlY3QoXCIjdGFncyAuZmItYm94XCIpKTtcblx0XHRcdFx0XHRcdC8vYWxlcnQoXCJDYW4ndCBmaW5kIHRhZ3Mgb24gYW4gdW5zYXZlZCBvYmplY3RcIik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjYWNoZTogZmFsc2UsXG5cdFx0XHRcdGNvbnRlbnRUeXBlOiBmYWxzZSxcblx0XHRcdFx0cHJvY2Vzc0RhdGE6IGZhbHNlXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cdGJ1aWxkTW9kdWxlOiBmdW5jdGlvbihkYXRhKXtcblx0XHRjb25zb2xlLmxvZygnQnVpbGRpbmcgdGFncyBtb2R1bGUuJyk7XG5cdFx0dmFyIHRhZ3MgPSBuZXcgUGF0aE9TLm1vZHVsZSh7XG5cdFx0XHRuYW1lOiBcInRhZ3NcIixcblx0XHRcdHRpdGxlOiBcIlRhZ3NcIixcblx0XHRcdHR5cGU6IFwidGFnc1wiLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdGNsb3NlTW9kdWxlOiBkYXRhLmNsb3NlTW9kdWxlXG5cdFx0fSk7XG5cdH0sXG5cdG51bGxPYmplY3Q6IGZ1bmN0aW9uIChkaXYpIHtcblx0XHRkaXYuaW5zZXJ0KFwiZGl2XCIsXCI6Zmlyc3QtY2hpbGRcIikuY2xhc3NlZChcInRhZ2RpdlwiLCB0cnVlKS5hcHBlbmQoXCJsYWJlbFwiKS50ZXh0KFwiWW91IGNhbm5vdCBhZGQgdGFncyB0byBpdC5cIik7XG5cdFx0ZGl2Lmluc2VydChcImRpdlwiLFwiOmZpcnN0LWNoaWxkXCIpLmNsYXNzZWQoXCJ0YWdkaXZcIiwgdHJ1ZSkuYXBwZW5kKFwibGFiZWxcIikudGV4dChcIlNvcnJ5LCB0aGlzIG9iamVjdCBoYXMgbm90IGJlIHNhdmVkLlwiKTtcblx0fSxcblx0ZHJhd1RhZ0J5SWQ6IGZ1bmN0aW9uKGJveCwgaWQsIGRlbGV0YWJsZSkge1xuXHRcdCQuYWpheChcIi9QYXRoT1MvVGFnL2xvb2tVcD9pZD1cIitpZCwge3N1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEpe1xuXHRcdFx0UGF0aE9TLnRhZ3MuZHJhd1RhZyhib3gsIGRhdGEsIGRlbGV0YWJsZSk7XG5cdFx0fX0pO1xuXHR9LFxuXHRkcmF3VGFnOiBmdW5jdGlvbiAoIGJveCwgZGF0YSwgZGVsZXRhYmxlICkge1xuXHRcdGlmIChkYXRhID09IFwiZmFpbFwiKSB7XG5cdFx0XHRhbGVydChcIlNvcnJ5LCB5b3UgY2Fubm90IHNldCBhIHJlc2VydmVkIHNtYXJ0IHRhZ1wiKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpdiA9IGRhdGEuaXNBdXRvID8gYm94Lmluc2VydCgnZGl2JywgJzpmaXJzdC1jaGlsZCcpOiBib3guaW5zZXJ0KCdkaXYnLCAndGV4dGFyZWEnKTtcblxuXHRcdFx0ZGl2LmF0dHIoJ2NsYXNzJywgXCJ0YWdkaXYgdGFnLVwiK2RhdGEuaWQpXG5cdFx0XHRcdC5kYXR1bShkYXRhKVxuXHRcdFx0XHQuY2xhc3NlZChcImlzQXV0b1wiLCBkYXRhLmlzQXV0bylcblx0XHRcdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcztcblxuXHRcdFx0XHRcdC8vIElmIHdlJ3JlIGVkaXRpbmcsIGFuZCBpdCdzIG5vdCBhdXRvLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGlzIHRhZy5cblx0XHRcdFx0XHRpZighZC5pc0F1dG8gJiYgZDMuc2VsZWN0KFwiI3RhZ3NcIikuY2xhc3NlZChcImVkaXRpbmdcIikpIHtcblx0XHRcdFx0XHRcdC8vIERFTEVURSBUQUchISFcblx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFBhdGhPUy5jb250cm9sbGVyLFxuXHRcdFx0XHRcdFx0XHRvYmppZDogUGF0aE9TLnRhZ3MuY3VycmVudF9vYmplY3QsXG5cdFx0XHRcdFx0XHRcdHRhZ2lkOiBkLmlkXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0JC5hamF4KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogXCJERUxFVEVcIixcblx0XHRcdFx0XHRcdFx0dXJsOiBcIi9QYXRoT1MvdGFnL3JlbW92ZUxpbms/XCIgKyAkLnBhcmFtKHBhcmFtcyksXG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihyZXN1bHQgIT0gJ2ZhaWwnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQkKHRoYXQpLnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYocmVsb2FkR3JpZCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZWxvYWRHcmlkKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0XHRjYWNoZTogZmFsc2UsXG5cdFx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0cHJvY2Vzc0RhdGE6IGZhbHNlXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Ly8gT3RoZXJ3aXNlLCByZWRpcmVjdCB0byB0aGUgc2VhcmNoIHBhZ2UuXG5cdFx0XHRcdFx0XHRkMy5zZWxlY3QodGhhdCkuc2VsZWN0KFwiLnRvb2x0aXBcIikuY2xhc3NlZChcImRpc21pc3NcIiwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0ZGl2LmFwcGVuZCgnc3BhbicpLnRleHQoZGF0YS5sYWJlbCk7XG5cblxuXHRcdFx0dmFyIHRleHQgPSBkYXRhLmRlc2NyaXB0aW9uIHx8IFwiRW50ZXIgRGVzY3JpcHRpb24gSGVyZS5cIjtcblx0XHRcdHZhciB0b29sdGlwID0gZGl2LmFwcGVuZCgnZGl2JykuY2xhc3NlZCgndG9vbHRpcCBmYi1ib3gnLCB0cnVlKTtcblxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoXCJidXR0b25cIikudGV4dChcIlNlYXJjaFwiKS5vbihcImNsaWNrXCIsZnVuY3Rpb24oZCl7XG5cdFx0XHRcdGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR3aW5kb3cubG9jYXRpb24uaHJlZiA9IFwiL1BhdGhPUy9zZWFyY2g/cT1cIitkLmxhYmVsO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRvb2x0aXAuYXBwZW5kKFwiYnV0dG9uXCIpLnRleHQoXCJWaWV3XCIpLm9uKFwiY2xpY2tcIixmdW5jdGlvbihkKXtcblx0XHRcdFx0ZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gXCIvUGF0aE9TL1RhZy9TaG93L1wiK2QuaWQ7XG5cdFx0XHR9KTtcblxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoXCJidXR0b25cIikudGV4dChcIkVkaXRcIikub24oXCJjbGlja1wiLCBmdW5jdGlvbihkKXtcblxuXHRcdFx0fSk7XG5cblxuXHRcdFx0dG9vbHRpcC5hcHBlbmQoJ2knKS5jbGFzc2VkKCdmYSBmYS1jbG9zZSBmYS1sZycsIHRydWUpLm9uKCdjbGljaycsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR0b29sdGlwLmNsYXNzZWQoXCJlZGl0XCIsIGZhbHNlKTtcblx0XHRcdH0pO1xuXG5cdFx0XHRpZiAoZGVsZXRhYmxlKSB7XG5cdFx0XHRcdHRvb2x0aXAuYXBwZW5kKCdpJykuY2xhc3NlZCgnZmEgZmEtdHJhc2ggZmEtbGcnLCB0cnVlKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRcdGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdGlmKGNvbmZpcm0oJ1JlbW92ZSB0YWcgXCInK2RhdGEubGFiZWwrJ1wiIGZyb20gdGhpcyBvYmplY3Q/JykpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFBhdGhPUy5jb250cm9sbGVyLFxuXHRcdFx0XHRcdFx0XHRvYmppZDogUGF0aE9TLnRhZ3MuY3VycmVudF9vYmplY3QsXG5cdFx0XHRcdFx0XHRcdHRhZ2lkOiBkYXRhLmlkXG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0JC5hamF4KHtcblx0XHRcdFx0XHRcdFx0dHlwZTogXCJERUxFVEVcIixcblx0XHRcdFx0XHRcdFx0dXJsOiBcIi9QYXRoT1MvdGFnL3JlbW92ZUxpbms/XCIgKyAkLnBhcmFtKHBhcmFtcyksXG5cdFx0XHRcdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0XHRcdFx0XHRpZihyZXN1bHQgIT0gJ2ZhaWwnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHQkKCcudGFnLScrZGF0YS5pZCkucmVtb3ZlKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZihyZWxvYWRHcmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJlbG9hZEdyaWQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0XHRcdGNhY2hlOiBmYWxzZSxcblx0XHRcdFx0XHRcdFx0Y29udGVudFR5cGU6IGZhbHNlLFxuXHRcdFx0XHRcdFx0XHRwcm9jZXNzRGF0YTogZmFsc2Vcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRvb2x0aXAuYXBwZW5kKCdpJykuY2xhc3NlZCgnZmEgZmEtY2hlY2sgZmEtbGcnLCB0cnVlKS5vbignY2xpY2snLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dG9vbHRpcC5jbGFzc2VkKFwiZGlzbWlzc1wiLCBmYWxzZSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly92YXIgdGV4dCA9IGRhdGEuZGVzY3JpcHRpb24gPT09IFwiXCIgPyBcIkVudGVyIERlc2NyaXB0aW9uIEhlcmUuXCIgOiBkYXRhLmRlc2NyaXB0aW9uO1xuXHRcdFx0dG9vbHRpcC5hcHBlbmQoJ3AnKS5jbGFzc2VkKFwidHRfZGVzY3JpcHRpb25cIiwgdHJ1ZSkudGV4dCh0ZXh0KTtcblx0XHRcdHRvb2x0aXAuYXBwZW5kKCdpbnB1dCcpLmF0dHIoJ3ZhbHVlJywgdGV4dCkub24oXCJrZXlkb3duXCIsIGZ1bmN0aW9uKCl7XG5cdFx0XHRcdFx0dmFyIGUgPSBkMy5ldmVudDtcblx0XHRcdFx0XHRpZihlICYmIGUua2V5Q29kZSAmJiBlLmtleUNvZGUgPT0gMTMpIHtcblx0XHRcdFx0XHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRcdFx0XHRcdGRlc2NyaXB0aW9uOiAkKHRoaXMpLnZhbCgpLFxuXHRcdFx0XHRcdFx0XHRpZDogZGF0YS5pZFxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdCQuYWpheChcIi9QYXRoT1MvVGFnL3B1dERlc2NyaXB0aW9uP1wiKyAkLnBhcmFtKHBhcmFtcyksIHtcblx0XHRcdFx0XHRcdFx0c3VjY2VzczogZnVuY3Rpb24oKXtcblx0XHRcdFx0XHRcdFx0XHQkKFwiLnRhZy1cIitkYXRhLmlkK1wiIGlucHV0XCIpLnZhbChwYXJhbXMuZGVzY3JpcHRpb24pO1xuXHRcdFx0XHRcdFx0XHRcdCQoXCIudGFnLVwiK2RhdGEuaWQrXCIgcFwiKS50ZXh0KHBhcmFtcy5kZXNjcmlwdGlvbik7XG5cdFx0XHRcdFx0XHRcdFx0dG9vbHRpcC5jbGFzc2VkKFwiZWRpdFwiLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHRcdFx0dG9vbHRpcC5jbGFzc2VkKFwiZGlzbWlzc1wiLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRpZihyZWxvYWRHcmlkKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZWxvYWRHcmlkKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cblxuXHRcdFx0dG9vbHRpcC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGQpe1xuXHRcdFx0XHRkMy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0dG9vbHRpcC5jbGFzc2VkKFwiZWRpdFwiLCB0cnVlKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblx0YWRkVGFnOiBmdW5jdGlvbiAoZGl2LCB0YWcsIGNvbnRyb2xsZXIsIGlkKSB7XG5cdFx0aWYoIHR5cGVvZiBjb250cm9sbGVyID09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRjb250cm9sbGVyID0gUGF0aE9TLmNvbnRyb2xsZXI7XG5cdFx0fVxuXHRcdGlmKCB0eXBlb2YgaWQgPT0gJ3VuZGVmaW5lZCcgKXtcblx0XHRcdGlkID0gUGF0aE9TLnRhZ3MuY3VycmVudF9vYmplY3Q7XG5cdFx0fVxuXHRcdGlmKCBjb250cm9sbGVyICYmIHRhZyAmJiBpZCApIHtcblx0XHRcdHZhciBwYXJhbXMgPSB7XG5cdFx0XHRcdHR5cGU6IGNvbnRyb2xsZXIsXG5cdFx0XHRcdGlkOiBpZCxcblx0XHRcdFx0dGFnOiB0YWcsXG5cdFx0XHRcdHVzZXI6IFBhdGhPUy51c2VyXG5cdFx0XHR9O1xuXHRcdFx0JC5hamF4KHtcblx0XHRcdFx0dHlwZTogXCJQT1NUXCIsXG5cdFx0XHRcdHVybDogXCIvUGF0aE9TL3RhZy9hZGRUYWc/XCIgKyAkLnBhcmFtKHBhcmFtcyksXG5cdFx0XHRcdHN1Y2Nlc3M6IGZ1bmN0aW9uIChkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBkID09IFwic3RyaW5nXCIpIHtcblx0XHRcdFx0XHRcdGFsZXJ0KGQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoZGl2LnNlbGVjdChcIi50YWctXCIrIGQuaWQpLmVtcHR5KCkpIHtcblx0XHRcdFx0XHRcdFx0UGF0aE9TLnRhZ3MuZHJhd1RhZyhkaXYsIGQsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHQkKCcjdGFnX3RleHRfYXJlYScpLnZhbCgnJyk7XG5cdFx0XHRcdFx0XHRcdGlmKHJlbG9hZEdyaWQpIHtcblx0XHRcdFx0XHRcdFx0XHRyZWxvYWRHcmlkKCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGNhY2hlOiBmYWxzZSxcblx0XHRcdFx0Y29udGVudFR5cGU6IGZhbHNlLFxuXHRcdFx0XHRwcm9jZXNzRGF0YTogZmFsc2Vcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zb2xlLmxvZyhcIldlIGRvbid0IGhhdmUgYSBjb250cm9sbGVyLCB0YWcgb3IgaWQuXCIpO1xuXHRcdFx0Y29uc29sZS5sb2coY29udHJvbGxlcik7XG5cdFx0XHRjb25zb2xlLmxvZyh0YWcpO1xuXHRcdFx0Y29uc29sZS5sb2coaWQpO1xuXHRcdH1cblx0fVxufTtcblxuXG5cblBhdGhPUy5wcmludFFDID0gZnVuY3Rpb24oZGF0YSkge1xuXHR2YXIgbGFiZWwgPSBkYXRhLmRpdi5hcHBlbmQoXCJoNFwiKVxuXHRcdFx0XHQuY2xhc3NlZChcImZsYWdcIiwgdHJ1ZSk7XG5cblx0aWYoZGF0YS5hdXRob3Jpc2VkID09PSBudWxsKSB7XG5cdFx0bGFiZWwudGV4dChcIlFDIE5vdCBTZXRcIikuY2xhc3NlZChcInVua25vd25cIiwgdHJ1ZSk7XG5cdH0gZWxzZSBpZiAoZGF0YS5wYXNzZmFpbEZsYWcpIHtcblx0XHRsYWJlbC50ZXh0KFwiUUMgUGFzc2VkXCIpLmNsYXNzZWQoXCJwYXNzZWRcIiwgdHJ1ZSk7XG5cdH0gZWxzZSBpZiAoIWRhdGEucGFzc2ZhaWxGbGFnKSB7XG5cdFx0bGFiZWwudGV4dChcIlFDIEZhaWxlZFwiKTtcblx0fVxuXG4gICAgLy9cbiAgICAvL1xuXHQvL2lmKGRhdGEucGFzc2ZhaWxGbGFnKSB7XG5cdC8vXHRxY0xhYmVsLnRleHQoXCJRQyBQYXNzZWRcIikuY2xhc3NlZChcInBhc3NlZFwiLCB0cnVlKTtcblx0Ly99IGVsc2Uge1xuXHQvL1x0cWNMYWJlbC50ZXh0KFwiUUMgRmFpbGVkXCIpO1xuXHQvL31cbiAgICAvL1xuXHQvL2NvbnNvbGUubG9nKFwiZGF0YSBpczogXCIpO1xuXHQvL2NvbnNvbGUubG9nKGRhdGEpO1xuXHQvL2lmKGRhdGEuYXV0aG9yaXNlZFFjID09PSBudWxsKSB7XG5cdC8vXHRhdXRob3Jpc2VkTGFiZWwudGV4dChcIlFDIEF1dGhvcmlzYXRpb24gTm90IFNldFwiKS5jbGFzc2VkKFwidW5rbm93blwiLCB0cnVlKTtcblx0Ly99IGVsc2UgaWYgKGRhdGEuYXV0aG9yaXNlZFFjRmxhZykge1xuXHQvL1x0YXV0aG9yaXNlZExhYmVsLnRleHQoXCJRQyBBdXRob3Jpc2VkXCIpLmNsYXNzZWQoXCJwYXNzZWRcIiwgdHJ1ZSk7XG5cdC8vfSBlbHNlIGlmICghZGF0YS5hdXRob3Jpc2VkUWNGbGFnKSB7XG5cdC8vXHRhdXRob3Jpc2VkTGFiZWwudGV4dChcIlFDIE5vdCBBdXRob3Jpc2VkXCIpO1xuXHQvL31cbn07XG5cblxuXG5cbi8vIFRoaXMgY29kZSBpcyBmb3IgY29udHJvbGxpbmcgSUdWLmpzXG4vLyBES0dNIDMxLUF1Z3VzdC0yMDE2XG5cblBhdGhPUy5pZ3YgPSB7XG5cdGxvYWRlZDogZmFsc2UsXG5cdG9wdGlvbnM6IHt9LFxuXHRpbml0OiBmdW5jdGlvbihpZ3ZEaXYsIGRhdGFVcmwsIHNhbXBsZSwgcGFuZWwsIHNhbXBsaW5nRGVwdGgpIHtcblxuXHRcdHZhciBiYWlVcmwgPSBkYXRhVXJsK3NhbXBsZStcIi5iYWlcIixcblx0XHRcdGJhbVVybCA9IGRhdGFVcmwrc2FtcGxlK1wiLmJhbVwiLFxuXHRcdFx0dmNmVXJsID0gZGF0YVVybCtzYW1wbGUrXCIudmNmXCI7XG5cblx0XHR2YXIgYmFzZVVybCA9IGRhdGFVcmwuc3BsaXQoXCJQYXRob2xvZ3lcIilbMF0sXG5cdFx0XHRwYW5lbEJlZFVybCA9IGJhc2VVcmwgKyBcIlBhbmVscy9cIiArIHBhbmVsICsgXCIvQW1wbGljb24uYmVkXCIsXG5cdFx0XHRwYW5lbFRzdlVybCA9IGJhc2VVcmwgKyBcIlBhbmVscy9cIiArIHBhbmVsICsgXCIvQW1wbGljb24udHN2XCI7XG5cblx0XHRQYXRoT1MuaWd2LmRpdiA9IGlndkRpdjtcblx0XHRQYXRoT1MuaWd2Lm9wdGlvbnMgPSB7XG5cdFx0XHRzaG93S2FyeW86IFwiaGlkZVwiLFxuXHRcdFx0c2hvd05hdmlnYXRpb246IHRydWUsXG5cdFx0XHRzaG93Q2VudGVyR3VpZGU6IHRydWUsXG5cdFx0XHRyZWZlcmVuY2U6IHtcblx0XHRcdFx0ZmFzdGFVUkw6IFwiLy9kbjd5d2JtOWlzcThqLmNsb3VkZnJvbnQubmV0L2dlbm9tZXMvc2VxL2hnMTkvaGcxOS5mYXN0YVwiLCAvL3BlcmhhcHMgd2Ugc2hvdWxkIGNoYW5nZSB0aGlzIHRvIGEgcGV0ZXIgbWFjIGhvc3RlZCBoZzE5P1xuXHRcdFx0XHRpbmRleEZpbGU6IFwiL1BhdGhPUy9pZ3YvaGcxOS5mYXN0YS5mYWlcIixcblx0XHRcdFx0Y3l0b2JhbmRVUkw6IFwiL1BhdGhPUy9pZ3YvY3l0b0JhbmQudHh0XCIsXG5cdFx0XHRcdG9yZGVyOiAtOTk5OSAvLyBUaGlzIGlzIG92ZXJyaWRkZW4uLi4geW91IGNhbid0IHNldCBpdC4uLi4gaXQgZ2V0cyBkZWZhdWx0ZWQgdG8gLTk5OTksIHNvIGxldCdzIHNldCB0aGUgb3JkZXIgb2YgdGhlIG90aGVyIHRyYWNrcyBhcm91bmQgdGhpcyB2YWx1ZS5cblx0XHRcdH0sXG5cdFx0XHR0cmFja3M6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHVybDogdmNmVXJsLFxuXHRcdFx0XHRcdHR5cGU6IFwidmNmXCIsXG5cdFx0XHRcdFx0bGFiZWw6IFwiVkNGOiBcIitzYW1wbGUsXG5cdFx0XHRcdFx0b3JkZXI6IC0xMDAwMVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRuZXcgUGF0aE9TLmlndi5CQU0oYmFpVXJsLCBiYW1VcmwsIHNhbXBsZSwgc2FtcGxpbmdEZXB0aCksXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRuYW1lOiBwYW5lbCxcblx0XHRcdFx0XHR1cmw6IHBhbmVsQmVkVXJsLFxuXHRcdFx0XHRcdGluZGV4VVJMOiBwYW5lbFRzdlVybCxcblx0XHRcdFx0XHRkaXNwbGF5TW9kZTogXCJFWFBBTkRFRFwiLFxuXHRcdFx0XHRcdG9yZGVyOiAtOTk5OFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dXJsOiAnL1BhdGhPUy9pZ3YvaGcxOS1SZWZTZXFHZW5lcy5ndGYuZ3onLFxuXHRcdFx0XHRcdGluZGV4VVJMOiAnL1BhdGhPUy9pZ3YvaGcxOS1SZWZTZXFHZW5lcy5ndGYuZ3oudGJpJyxcblx0XHRcdFx0XHRuYW1lOiAnaGcxOSAtIEdlbmNvZGUgdjI0Jyxcblx0XHRcdFx0XHRmb3JtYXQ6ICdndGYnLFxuXHRcdFx0XHRcdG9yZGVyOiAtOTk5Nyxcblx0XHRcdFx0XHR2aXNpYmlsaXR5V2luZG93OiAxMDAwMDAwMFxuXHRcdFx0XHR9XG5cdFx0XHRdXG5cdFx0fTtcblxuXHR9LFxuXHRzZWFyY2g6IGZ1bmN0aW9uKGxvY3VzKSB7XG5cdFx0aWYoIVBhdGhPUy5pZ3YubG9hZGVkKSB7IC8vIEZpcnN0IGxvYWQhIExldCdzIGRvIGluaXQgc3R1ZmZcblx0XHRcdFBhdGhPUy5pZ3YubG9hZGVkID0gdHJ1ZTtcblx0XHRcdGlndi5jcmVhdGVCcm93c2VyKFBhdGhPUy5pZ3YuZGl2LCBQYXRoT1MuaWd2Lm9wdGlvbnMpO1xuXHRcdFx0JChcIiNmb290ZXItbWVzc2FnZVwiKS5yZW1vdmUoKTtcblx0XHR9XG5cdFx0Ly8gQnJvd3NlIHRvIHRoZSBsb2N1cyB0aGF0IHRoZSB1c2VyIHdhbnRzIHRvIHNlZVxuXHRcdGlndi5icm93c2VyLnNlYXJjaChsb2N1cyk7XG5cdH0sXG5cdGFkZEJBTTogZnVuY3Rpb24oc2FtcGxlLCBkYXRhVXJsLCBzYW1wbGluZ0RlcHRoKSB7XG5cdFx0aWYoc2FtcGxlICYmIGRhdGFVcmwpIHtcblx0XHRcdHZhciBiYWlVcmwgPSBkYXRhVXJsK3NhbXBsZStcIi5iYWlcIixcblx0XHRcdFx0YmFtVXJsID0gZGF0YVVybCtzYW1wbGUrXCIuYmFtXCI7XG5cdFx0XHR2YXIgbmV3VHJhY2sgPSBuZXcgUGF0aE9TLmlndi5CQU0oYmFpVXJsLCBiYW1VcmwsIHNhbXBsZSwgc2FtcGxpbmdEZXB0aCk7XG5cblx0XHRcdGlmKFBhdGhPUy5pZ3YubG9hZGVkKSB7XG5cdFx0XHRcdGlndi5icm93c2VyLmxvYWRUcmFjayhuZXdUcmFjayk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoT1MuaWd2Lm9wdGlvbnMudHJhY2tzLnB1c2gobmV3VHJhY2spO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRhbGVydChcIlRoZXJlIHdhcyBhbiBlcnJvciwgZGF0YSBub3QgZm91bmQuXCIpO1xuXHRcdH1cblx0fSxcblx0QkFNOiBmdW5jdGlvbihiYWlVcmwsIGJhbVVybCwgc2FtcGxlLCBzYW1wbGluZ0RlcHRoKXtcblxuXHRcdC8vIElmIHNhbXBsaW5nRGVwdGggaXMgbm90IHByb3ZpZGVkLCBzZXQgIGl0IHRvIDI1MDAuXG5cdFx0Ly8gVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBpbiBzZXFydW4vc2hvdy5nc3Bcblx0XHRzYW1wbGluZ0RlcHRoID0gc2FtcGxpbmdEZXB0aCB8fCAyNTAwO1xuXG5cdFx0dGhpcy5pbmRleFVSTCA9IGJhaVVybDtcblx0XHR0aGlzLnVybCA9IGJhbVVybDtcblx0XHR0aGlzLmxhYmVsID0gc2FtcGxlO1xuXHRcdHRoaXMudHlwZSA9IFwiYmFtXCI7XG5cdFx0dGhpcy5hbGlnbm1lbnRSb3dIZWlnaHQgPSAxO1xuXHRcdHRoaXMubWF4Um93cyA9IDk5OTk5O1xuXHRcdHRoaXMub3JkZXIgPSAtMTAwMDA7XG5cdFx0dGhpcy5oZWlnaHQgPSA1MDA7XG5cdFx0dGhpcy5hdXRvSGVpZ2h0ID0gdHJ1ZTtcblx0XHR0aGlzLnNhbXBsaW5nRGVwdGggPSBzYW1wbGluZ0RlcHRoO1xuXHRcdHRoaXMuY29sb3JCeSA9IFwic3RyYW5kXCI7XG5cdFx0dGhpcy5uZWdTdHJhbmRDb2xvciA9IFwicmdiKDE1MCwgMTUwLCAyMzApXCI7XG5cdFx0dGhpcy5wb3NTdHJhbmRDb2xvciA9IFwicmdiKDIzMCwgMTUwLCAxNTApXCI7XG5cdFx0dGhpcy5kZWxldGlvbkNvbG9yID0gXCJibGFja1wiO1xuXHRcdHRoaXMuc2tpcHBlZENvbG9yID0gXCJyZ2IoMTUwLCAxNzAsIDE3MClcIjtcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5cblxuXG5cblxuXG5QYXRoT1MuaW5pdCA9IGZ1bmN0aW9uKG9wdGlvbnMpe1xuXHRQYXRoT1MubW9kdWxlcy5pbml0KG9wdGlvbnMpO1xuXHRQYXRoT1MuaG90a2V5cy5pbml0KCk7XG5cdFBhdGhPUy5oaXN0b3J5LmluaXQoKTtcblx0Ly9QYXRoT1Muc2FmZXR5LmluaXQoKTtcbn07XG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG4iXSwiZmlsZSI6InNjcmlwdHMubWluLmpzIiwic291cmNlUm9vdCI6Ii9zb3VyY2UvIn0=
